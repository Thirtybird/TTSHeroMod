#include constants
#include utilityfunctions

-- [[

-- Globals being worked on. Eventually move to constants

-- ]]
noteBooksToIgnore = {Black = true,Blue=true,Red=true,Green=true,Yellow=true,Orange=true,Teal=true,Purple=true,Pink=true,Brown=true,White=true,Rules=true}
colorOrder = {"#CCCCCC","Blue"  ,    "Red",  "Green","Yellow","Orange","Teal"  ,"Purple","Pink"  ,"Brown"}
colorDesc  = {"black",  "blue"  ,    "red",  "green","yellow","orange","teal"  ,"purple","pink"  ,"brown"}
--rollerList = {Black = "142c93", Purple = "e129fa", Red = "e9ee27", Orange = "c9b16e", Yellow = "12c392", Green = "10a32d", Blue = "803fa5" }
useOCV = true
players = {
  black  = {loadedLine="",active="true",  location="MiddleRight", offsetXY = "0 0", prefix="BLA", roller = "142c93", desc = "Black"  , color = "#CCCCCC", combatColor = "#888888", character = {}, name = "",sections=copy(sections), GMView=false,},
  blue   = {loadedLine="",active="false", location="MiddleRight", offsetXY = "0 0", prefix="BLU", roller = "803fa5", desc = "Blue"   , color = "#1E87FF", combatColor = "#1E87FF", character = {}, name = "",sections=copy(sections), GMView=false,},
  red    = {loadedLine="",active="false", location="MiddleRight", offsetXY = "0 0", prefix="RED", roller = "e9ee27", desc = "Red"    , color = "#DA1917", combatColor = "#DA1917", character = {}, name = "",sections=copy(sections), GMView=false,},
  green  = {loadedLine="",active="false", location="MiddleRight", offsetXY = "0 0", prefix="GRE", roller = "10a32d", desc = "Green"  , color = "#30B22A", combatColor = "#30B22A", character = {}, name = "",sections=copy(sections), GMView=false,},
  yellow = {loadedLine="",active="false", location="MiddleRight", offsetXY = "0 0", prefix="YEL", roller = "12c392", desc = "Yellow" , color = "#E6E42B", combatColor = "#E6E42B", character = {}, name = "",sections=copy(sections), GMView=false,},
  orange = {loadedLine="",active="false", location="MiddleRight", offsetXY = "0 0", prefix="ORA", roller = "c9b16e", desc = "Orange" , color = "#F3631C", combatColor = "#F3631C", character = {}, name = "",sections=copy(sections), GMView=false,},
  teal   = {loadedLine="",active="false", location="MiddleRight", offsetXY = "0 0", prefix="TEA", roller = "12b2fd", desc = "Teal"   , color = "#20B09A", combatColor = "#20B09A", character = {}, name = "",sections=copy(sections), GMView=false,},
  purple = {loadedLine="",active="false", location="MiddleRight", offsetXY = "0 0", prefix="PUR", roller = "e129fa", desc = "Purple" , color = "#9F1FEF", combatColor = "#9F1FEF", character = {}, name = "",sections=copy(sections), GMView=false,},
  pink   = {loadedLine="",active="false", location="MiddleRight", offsetXY = "0 0", prefix="PIN", roller = "4caea4", desc = "Pink"   , color = "#F46FCD", combatColor = "#F46FCD", character = {}, name = "",sections=copy(sections), GMView=false,},
  brown  = {loadedLine="",active="false", location="MiddleRight", offsetXY = "0 0", prefix="BRO", roller = "cd5bb5", desc = "Brown"  , color = "#703A16", combatColor = "#703A16", character = {}, name = "",sections=copy(sections), GMView=false,},
}

preToCol = {
  BLA = "black",
  BLU = "blue",
  RED = "red",
  GRE = "green",
  YEL = "yellow",
  ORA = "orange",
  TEA = "teal",
  PUR = "purple",
  PIN = "pink",
  BRO = "brown",
}

submitCache = { pl = "", va = "", id = "", ti = 0}
charLib = {} -- Character Library which the browsers access by line number
charLibGUID = {} -- Character Library which the browsers access by line number
character = {} -- Base character for deploying
bCharacter = {} -- Base character for deploying
currentNotebook = {}
lastMatch = 0

modVersion = "0.97 (2023032801)"

ccplayers = {}
ccnonCombat = {}

maxLibSize = 50
NPCStartSlot = 10

turn=1
segment=12
ccsegmentNumbers = {"①","②","③","④","⑤","⑥","⑦","⑧","⑨","<b>⑩</b>","<b>⑪</b>","<b>⑫</b>","<b>ⓡ</b>"}
ccsegmentNumPlain = {"①","②","③","④","⑤","⑥","⑦","⑧","⑨","⑩","⑪","⑫"}

cchideConfigToggle = true
cccombatMode = false

statOrder = {
  ["str"]   = {base = true,  numTab = 2, color = "#CCCCCC",  displayName = "STR",  fullName = "Strength"},
  ["dex"]   = {base = true,  numTab = 2, color = "#CCCCCC",  displayName = "DEX",  fullName = "Dexterity"},
  ["con"]   = {base = true,  numTab = 2, color = "#CCCCCC",  displayName = "CON",  fullName = "Constitution"},
  ["body"]  = {base = false, numTab = 1, color = bodyColor,  displayName = "BODY", fullName = "Body"},
  ["int"]   = {base = true,  numTab = 3, color = "#CCCCCC",  displayName = "INT",  fullName = "Intelligence"},
  ["ego"]   = {base = true,  numTab = 2, color = "#CCCCCC",  displayName = "EGO",  fullName = "Ego"},
  ["pre"]   = {base = true,  numTab = 2, color = "#CCCCCC",  displayName = "PRE",  fullName = "Presence"},
  ["stun"]  = {base = false, numTab = 1, color = stunColor,  displayName = "STUN", fullName = "Stun"},
  ["blank"] = {base = false, numTab = 1, color = "#000000",  displayName = "",     fullName = "Blank"},
  ["spd"]   = {base = false, numTab = 2, color = "#CCCCCC",  displayName = "SPD",  fullName = "Speed"},
  ["rec"]   = {base = false, numTab = 2, color = "#CCCCCC",  displayName = "REC",  fullName = "Recovery"},
  ["end"]   = {base = false, numTab = 2, color = endColor,   displayName = "END",  fullName = "Endurance"},
  ["ocv"]   = {base = false, numTab = 2, color = "#9999DD",  displayName = "OCV",  fullName = "Offensive Combat Value"},
  ["dcv"]   = {base = false, numTab = 2, color = "#9999DD",  displayName = "DCV",  fullName = "Defensive Combat Value"},
  ["omcv"]  = {base = false, numTab = 1, color = "#9999DD",  displayName = "OMCV", fullName = "Offensive Mental Combat Value"},
  ["dmcv"]  = {base = false, numTab = 1, color = "#9999DD",  displayName = "DMCV", fullName = "Defensive Mental Combat Value"},
  ["pd"]    = {base = false, numTab = 3, color = "#9999DD",  displayName = "PD",   fullName = "Physical Defence"},
  ["pdr"]   = {base = false, numTab = 2, color = "#9999DD",  displayName = "rPD",  fullName = "Physical Defence Resistant"},
  ["ed"]    = {base = false, numTab = 3, color = "#9999DD",  displayName = "ED",   fullName = "Energy Defence"},
  ["edr"]   = {base = false, numTab = 2, color = "#9999DD",  displayName = "rED",  fullName = "Energy Defence Resistant"},
}

-- [[

-- potential utility Functions

-- ]]

function trim(s)
   return s:match'^%s*(.*%S)' or ''
end

function updateUI(id, attribute, update) --update UI with new attribute
  if update == nil then
    log(id, "id updateUI")
    log(attribute, "attribute updateUI")
    log(update, "update updateUI")
  end
  UI.setAttribute (id, attribute, update)
end

function updatesUI(id, attribs)
    UI.setAttributes (id, attribs)
end

function printArgs(player, state, id, callfunction)
  print("Function: ", callfunction,", Player: ",player,", State: ", state,", ID: ",id)
end

function getRollFromStat(statValue)
  return 9 + math.floor((statValue/5) + 0.5)
end

function rollToNum(rollValue)
  if rollValue == nil or rollValue == "" then -- empty skill roll
    return 0
  else
    local roll = copy(rollValue)
    -- should have a real string value with potentially multiple rolls.
    if string.len(roll) > 3 then
      roll = trim(string.gsub(roll, "%(%S*%)", "")) -- remove any secondary rolls
    end

    local numToReturn = getNumber(roll:sub(1, -2))
    if type(numToReturn) == "number" then
      return numToReturn
    else
      return 0
    end
  end
end

function toggleState(player, state, id)
  updateUI(id, "isOn", state)
end

function textState(player, state, id)
  updateUI(id, "text", state)
end

function getStatValue(source, statToReturn, porsOverride)
  --pl(statToReturn)
  return source[statToReturn][iif(porsOverride != nil, porsOverride, source[statToReturn].current)].value + source[statToReturn].mod
end

function getStatOrigin(source, statToReturn, porsOverride)
  --pl(statToReturn)
  return source[statToReturn][iif(porsOverride != nil, porsOverride, source[statToReturn].current)].origin
end

function getStatMod(source, statToReturn)
  --pl(statToReturn)
  return source[statToReturn].mod
end

function getClick(state)
  local click = {left=false, right=false, middle=false}
  local theState = tonumber(state)
  if theState > -1 then return click end
  if theState == -1 then
    click.left = true
  elseif theState == -2 then
    click.right = true
  else
    click.middle = true
  end
  return click
end

function getPre(id) -- use the id to determine the current player prefix
  return string.sub(id, 1, 3)
end

function shadeFail(test,color,trans) -- test for false and shade
	if not(test) then
		if string.sub(color, 1, 1) == "#" then
			return color .. trans
		else
			return "#" .. Color.fromString(color):toHex(false) .. trans
		end
	end
	return color
end

function makeStatusString(withBrackets, theChar)
  local statusArray = {}
  for key,status in pairs(theChar.status) do
      if status.isActive then
          table.insert(statusArray, status.shortName)
      end
  end
  if #statusArray == 0 then
      return ""
  else
      return iif(withBrackets,"(","") ..  table.concat(statusArray, ",") .. iif(withBrackets,")","")
  end
end

-- [[

-- External Called Functions

-- ]]

function exgetGlobalVars()  -- allows for easy retun of the common global variables
  local globalVars = {
    charLib = charLib,
    charLibGUID = charLibGUID,
    maxLibSize = maxLibSize,
    turn = turn,
    segment = segment
  }
  return globalVars
end

function exeditChar(params)
--  log("exeditChar: "..dump(params))
  sceditChar (params.player, params.value, params.id)
end

function exloadChar(params)
--  log("exloadChar: "..dump(params))
  scloadChar (params.player, params.value, params.id)
end


-- [[

-- Scene Control Functions

-- ]]

-- Window functions

function scShow(player, state, id) --
  --printArgs(player, state, id, "scShow")
  local showScene = iif(string.sub(id, 1, 1) == "s", true, false)
  if getClick(state).right and not(showScene) then -- right click on combat
    scaddAllActiveCombatant(player, state, id)
  end
  if gatb("playerrow","active") != showScene then -- check and do not change if already in that state
    for _,value in ipairs({"playerrow","charlistrow","activerow"}) do --scene UI
      updateUI(value, "active", showScene)
    end
    for _,value in ipairs({"oddCombatHeldRow","oddCombatTurnRow","oddCombatRow","oddCombatEndRow"}) do --combat ui
      updateUI(value, "active", not(showScene))
    end
    updateUI("sceneTab", "color", shadeFail(showScene,"#CCCCCC","33"))
    updateUI("combatTab", "color", shadeFail(not(showScene),"#CCCCCC","33"))
  end
end

function scchangeScrollHeight(numLines) -- alter the scroll height
  updatesUI("charlisttable", {
    preferredHeight = 34*numLines,
    height = 34*numLines,
  })
  return numLines
end

function sccloseBrowser(color) -- Close browser (for no characters in pool)
  players[color].viewing = false
  cbhideBrowserUI(color)
end

function scshowLine(line,bool) -- show or hide the line requested based on bool
  --local lineNum = twodigitnumber(line)
  updateUI(twodigitnumber(line) .. "row", "active", bool)
end

function scvisibleLines(color) -- Show all character lines of player color and hide the rest
  local countLines = 0
  for i = 1,#charLib do
    if charLib[i].currentColor != color then
      scshowLine(i,false)
    else
      scshowLine(i,true)
      countLines = countLines + 1
    end
  end
  return scchangeScrollHeight(countLines)
end

function scallvisibleLines() -- Show all character lines
  for i = 1,#charLib do
    scshowLine(i,true)
  end
  return scchangeScrollHeight(#charLib)
end

function scallVisibleCharacterLines() -- Show all loaded character lines
  local countLines = 0
  for i = 1,#charLib do
    if charLib[i].name != nil then
      scshowLine(i,true)
      countLines = countLines + 1
    else
      scshowLine(i,false)
    end
  end
  return scchangeScrollHeight(countLines)
end

function scallPlayersClick(player, value, id) -- clicked on all players icon
  if tonumber(value) == -1 then
    scallvisibleLines()
  else
    scallVisibleCharacterLines()
  end
end

function scselectLine (line, bool) -- select or deselect a character line
  updatesUI(line .. "row", {
    dontUseTableRowBackground = true,
    color = "#333333" .. iif(bool,"FF", "00"),
  })
  --print("We are at scselectLine ", line, " - ", bool)
  charLib[tonumber(line)].lineSelected = bool
end

function scinputAutoHint(player, value, id) -- autohint notebook names in the input field
  local count = 0
  if (string.len(value) > 4) and string.sub(value) != "http" then
    for key,title in ipairs(currentNotebook) do
      if (string.sub(title,1,lastMatch+1) == string.sub(value,1,lastMatch+1)) and (lastMatch > 4) then
        count = count + 1
        if count > 0 then
          potential = title
        end
      elseif string.sub(title,1,string.len(value)) == value then
        count = count + 1
        if count > 0 then
          potential = title
        end
      end
    end
    if count == 1 then
      updateUI(id, "text", potential)
      if lastMatch == 0 then
        lastMatch=string.len(value)
      else
        lastMatch=lastMatch + 1
      end
    end
  end
end

function sccharSubmit(player,value,id) -- if enter pressed in notebook field then call load character
  log("sccharSubmit player="..tostring(player).." value="..tostring(value).." id="..tostring(id))
  local oldSubmit = copy(submitCache)
  submitCache = {
    pl = player,
    va = value,
    id = id,
    ti = os.time()
  }
  --pl(submitCache.ti - oldSubmit.ti)
  -- if more than 1 second (positive 1 or more difference then accept input and simulate click on load)
  if string.sub(id,3) == "inputname" then
    if (submitCache.ti - oldSubmit.ti) > 1 then
      scloadChar(player, value, id)
    end
  end
end

-- Library functions

function scaddAllActiveCombatant(player, state, id)
  --print("got here")
  local lineNum = ""
  local characterSet = {}
  for i = 1,#charLib do
    lineNum = twodigitnumber(i)
    if charLib[i].name != nil then
      updatesUI(lineNum.."active", {
        text      = checkMark,
        fontStyle = "Bold",
        onClick   = "scactiveChar",
        tooltip   = "Will use in combat",
        combatState = true,
      })
      addToCombat(lineNum)
    end
  end
  ccreDrawByMode(CONST.noShowMsg)
  return characterSet
end

function scremoveCombatant(lineNum)

  local line = twodigitnumber(lineNum)
  for key,cp in ipairs(ccplayers) do
    if line == cp.guid then
      table.remove(ccplayers,key)
      break
    end
  end
  updatesUI(line.."active", {
    text      = crossMark,
    fontStyle = "Bold",
    onClick   = "scactiveChar",
    tooltip   = "Will not use in combat",
    combatState = false,
  })

end

function sccreateLibrary (numberOfCharacters) -- create empty character library
  for i=1,numberOfCharacters do
    table.insert(charLib, {})
  end
end

function scfindSelectedLine() -- search for currently selected line in library
  for i = 1,#charLib do
    if charLib[i].lineSelected then
      return twodigitnumber(i) -- linenumber
    end
  end
  return false
end

function scgetCharactersByColor(color) -- get list of characters by color and return name and line
  local characterSet = {}
  for i = 1,#charLib do
    if (charLib[i].currentColor == color) and (charLib[i].name != nil) then
        table.insert(characterSet, {name=charLib[i].name, line=twodigitnumber(i)})
    end
  end
  return characterSet
end

function scfindGMViewLine() -- search for currently selected line in library
  for i = 1,#charLib do
    if charLib[i].GMView then
      return twodigitnumber(i) -- linenumber
    end
  end
  return false
end

function scloadScene()
  --broadcastToAll("GM is Loading the scene...",stringColorToRGB("Red"))
  log("scloadScene - does nothing")
end

function scsaveScene()
  --broadcastToAll("GM is Saving the scene...",stringColorToRGB("Red"))
  if charLib then
    --log ("charlib: "..dump(charLib))
    for i=1, maxLibSize  do
      if charLib[i].name then
        if charLibGUID[i] then
          log (twodigitnumber(i).." "..charLib[i].name.." ("..charLibGUID[i]..") link ("..charLib[i].link..")")
        else
          log (twodigitnumber(i).." "..charLib[i].name.." - manually added")
        end
      end
    end -- for
  end
end

-- Character affecting functions

-- function is called when a player is already in the list and is selected
function scselectCharacter(player, value, id) -- select line or display character for GM
  local line = scgetLine(id)
  local lineNum = tonumber(line)
  local playerColor = string.lower(player.color)

  if tonumber(value) == -1 then -- left click select character for action
    local previousSelection = scfindSelectedLine() -- tidy old line highlight by finding the players last line
    if previousSelection then
      scselectLine (previousSelection, false)
    end
    scselectLine (line, true) -- highlight current selection
    for i = 1,#charLib do
      if charLib[i].lineSelected then
      end
    end
  elseif tonumber(value) == -2 then  -- right click display in Black browser
    scchangeGMBrowser(player, value, id)
  end
end

function scchangeGMBrowser(player, value, id)
  local line = scgetLine(id)
  local lineNum = tonumber(line)
  local playerColor = string.lower(player.color)
  local oldGMViewLine = scfindGMViewLine() -- find existing GMViewed line
  if oldGMViewLine then
    charLib[tonumber(oldGMViewLine)].GMView = false
  end
  charLib[lineNum].GMView = true
  scchangeCharacterInBrowser(playerColor, line)
  return
end

function scplayerIconClick(player, value, id) -- if line selected colour, filter on right click
  local newColor = string.sub(id,7)
  if tonumber(value) == -1 then -- left click
    local line = scfindSelectedLine() -- find current selected
    local lineNum = tonumber(line)
    local theChar = charLib[lineNum]
    if line then -- if got selected then update
      local oldColor = theChar.currentColor -- get previous color of selected item
      --local oldColor = charLib[lineNum].currentColor -- get previous color of selected item
      if oldColor != "black" then
        --charLib[lineNum].currentColor = "" -- wipe old color
        theChar.currentColor = "" -- wipe old color
        scupdateCharacterPool(oldColor) -- should always tell the old colour and the new colour about char pool change
      end
      if newColor == oldColor then -- same color, revert to black
        newColor = "black" -- set new color to black
      end
      theChar.currentColor = newColor -- change color for selected to black or any color
      if newColor != "black" then
        scupdateCharacterPool(newColor) -- update the colors for the newColor (non-black)
      end
      if theChar.GMView then
        cbupdateTitle(players["black"]) -- update the browser title
      end
      if cccombatMode then
        if ccIsInCombat(line) then -- keep test separate as second test is a potential 99 loop
          ccamendColour(line)
        end
      end
      updatesUI(line .. "charname", {
        currentColor = newColor,
        color        = players[newColor].color,
        tooltip      = "<color="..players[theChar.currentColor].color..">"..firstToUpper(charLib[lineNum].currentColor) .. " player</color>\n<color=#888888>l-click: </color>Select\n<color=#888888>r-click:</color>View",
      })
      -- Notify OLD colour browser no longer character to view
    end
  else
    scvisibleLines(newColor)
  end
end

function scchangeCharacterInBrowser(playerColor, line)
  players[playerColor].viewing = line
  cbreDrawUI(players[playerColor],true)
end

function scupdateCharacterPool(color)
  local charForColor = scgetCharactersByColor(color)
  if #charForColor > 0 then
    for i = 1,#charForColor do
      if charForColor[i].line == players[color].viewing then -- check if currentCharacter is still available and stick with it
        scchangeCharacterInBrowser(color, charForColor[i].line)
        return true
      end
    end
    scchangeCharacterInBrowser(color, charForColor[1].line)
    return true
  end
  sccloseBrowser(color)
  return false
end

function scaddChar(player, value, id) -- change to add character mode
  -- log ("scaddChar: player="..tostring(player).." value="..tostring(value).." id="..tostring(id))
  --[[local nbtest = getNotebookTabs()
  currentNotebook = {}
  lastMatch = 0
  for i=1,#nbtest do
    if not(noteBooksToIgnore[nbtest[i].title]) then
      table.insert(currentNotebook, nbtest[i].title)
    end
  end
  table.sort(currentNotebook)--]]
  lastMatch = 0
  local line = scgetLine(id)
  updatesUI(line.."line", {
    text    = "✗",
    tooltip = "Cancel",
    onClick = "sceditChar",
    fontStyle="Bold"
  })
  updateUI(line.."charname", "active", false)
  updatesUI(line.."inputname", {
    selected = true,
    active   = true,
  })
  updatesUI(line.."active", {
    text    = "Load",
    tooltip = "Load character",
    onClick = "scloadChar",
    fontStyle="Normal",
    active  = true,
  })
end

function sceditChar(player, value, id) -- edit or delete character
  -- log ("sceditChar: player="..tostring(player).." value="..tostring(value).." id="..tostring(id))
  --print("Line: ", string.sub(id,1,2) )
  value = getNumber(value)
  local line = scgetLine(id)
  local lineNum = tonumber(line)
  local charLoaded = iif(charLib[lineNum].name != nil, true ,false)
  if not(charLoaded) then -- left or right click no character
    updatesUI(line.."line", {
      text    = "Add",
      tooltip = "Click to add character",
      onClick = "scaddChar",
      fontStyle="Normal",
    })
    updateUI(line.."charname", "active", true)
    updatesUI(line.."inputname", {
      text   = "",
      selected = false,
      active = false,
    })
    updatesUI(line.."active", {
      text    = "Load",
      tooltip = "Load character",
      onClick = "scloadChar",
      active  = false,
      fontStyle="Normal",
    })
  elseif charLoaded and (value == -1) then -- left click with character
    updatesUI(line.."line", {
      text    = line,
      tooltip = "Click to edit character",
      onClick = "scaddChar",
    })
    updateUI(line.."charname", "active", true)
    updatesUI(line.."inputname", {
      selected = false,
      active = false,
    })
    --local gatb(line.."active", "combatState")
    updatesUI(line.."active", {
      text      = iif(gatb(line.."active", "combatState"),checkMark,crossMark),
      tooltip   = "Click to use in combat",
      onClick   = "scactiveChar",
      active    = true,
      fontStyle = "Bold"
    })
  elseif charLoaded and (value == -2) then -- right click with character
    log ("Deleting char from line "..twodigitnumber(line))
    updatesUI(line.."line", {
      text    = "Add",
      tooltip = "Click to add character",
      onClick = "scaddChar",
      fontStyle = "Normal"
    })
    updatesUI(line.."charname",   {
      text         = "Character",
      tooltip      = "Click to add character",
      currentColor = "black",
      color        = colorOrder[1],
      onClick      = "scaddChar",
      active       = true,
    })
    updatesUI(line.."inputname",  {
      text     = "",
      selected = false,
      active   = false,
    })
    updatesUI(line.."active", {
      text      = crossMark,
      tooltip   = "Click to use in combat",
      onClick   = "scactiveChar",
      active    = false,
      fontStyle = "Bold",
      combatState = false,
    })
    local whatColorWasLine = copy(charLib[lineNum].currentColor)
    if charLib[lineNum].GMView then
      sccloseBrowser("black")
    end
    charLib[lineNum] = {} -- remove character from Library
    if whatColorWasLine != "black" then
      scupdateCharacterPool(whatColorWasLine) -- update the colors for the newColor (non-black)
    end
    scselectLine (line, false)
    -- should remove GM character as well.
  end
end

-- fucntion is called when the load happens for a character
function scloadChar(player, value, id) -- take name from add character and load the named character
  -- log ("scloadChar: player="..tostring(player).." value="..tostring(value).." id="..tostring(id))
  --print("Line: ", string.sub(id,1,2) )
  local line = scgetLine(id)
  local inputName = ""
  local selectedCheck = false
  if scfindSelectedLine() == line then
    scselectLine (line, false)
  end
  if string.sub(id,3) == "inputname" then
    inputName = value
  else
    inputName = UI.getAttribute(line.."inputname", "text")
  end
  if (inputName == "") or (inputName == nil) then
    print("Character name not entered")
    return
  end
  -- if http or name get from location and hand off
  local loadedCharacter = {}
  if string.lower(string.sub(inputName, 1, 4)) == "http" then
    --print ("Get from web ",inputName)
    WebRequest.get(inputName, function(a) scgetFromWeb(a, line) end)
  else
    --print ("Get from notebook ",inputName) -- treat notebook like webreturn
    loadedCharacter = scgetFromWeb(scgetNotebookPage(inputName),line)
  end
end

function scgetCache(name)
  return copy(cachedChar[name])
end

function scisCached(name)
  if cachedChar[name] == nil then
    return false
  else
    return true
  end
end

function scsetCache(name, characterForCache)
  cachedChar[name] = copy(characterForCache)
end

function splitCharEntry(scgotName)
  local theChar=""
  local theHash= ""
  local potentialNum = 1
  if not(string.find(scgotName, "#",-5)) then
    theChar = copy(scgotName)
  else
    local hashStart, hashEnd = string.find(scgotName, "(#[x]?%d+)")
    if hashStart then
      theHash = string.sub(scgotName,hashStart,hashEnd)
      theChar = string.sub(scgotName,1,hashStart-1)
    end
    if string.find(theHash, "x") then
      local xStart, xEnd = string.find(theHash, "x")
      if xStart then
        if type(tonumber(string.sub(theHash,xStart+1))) == "number" then
          potentialNum = tonumber(string.sub(theHash,xStart+1))
        end
      end
    end
  end
  return {name=theChar,hash=theHash,numberOf=potentialNum}
end

function scgetNotebookPage(name) -- treat a notebook call like a webrequest
  local entry = splitCharEntry(name)
  local content=""
  local tabInfo = Notes.getNotebookTabs()
  for key,value in pairs(tabInfo) do
    if (value.title == entry.name) then
      content = value.body
      return {url=name,text=content,is_error=false}
    end
  end
  return {url=name,text=content,is_error=true}
end

function scgetFromWeb(webReturn, line) -- called by scloadChar to get the character from the web
    if webReturn.is_error then
        print("Error reading JSON from ", webReturn.url)
        return
    end
    -- check cache for existing resource
    local entry = splitCharEntry(webReturn.url)

    if not(scisCached(entry.name)) then-- if not cached then do load routine
      local gotChar = schandleCharacter(webReturn.url, webReturn.text, line)
      if gotChar != nil then
        scsetCache(entry.name, gotChar)
      else
        print (webReturn.url .. " not found") -- did not find chatacter anywhere
        return
      end
    end
    local startLoop = tonumber(line)
    local endLoop = math.min(startLoop + entry.numberOf - 1, maxLibSize)
    local count = 1
    for i=startLoop,endLoop do
      local gotChar = scgetCache(entry.name)
      gotChar.name = gotChar.originalName .. " " .. iif(entry.numberOf > 1, "#"..count ,entry.hash)
      gotChar.random = math.random(0,999)
      count = count + 1
      scstoreChar(copy(gotChar), twodigitnumber(i))
    end
end

function scstoreChar(gotChar, line) -- put the character in the library
    local lineNum = tonumber(line)
    if charLib[lineNum].GMView then
      sccloseBrowser("black")
    end
    charLib[lineNum] = gotChar -- Store in Library
    charLib[lineNum].lineIndex = line -- store index in library with character
    charLib[lineNum].currentColor = "black"
    sclinkGUID (lineNum)
    scnameFromMini (lineNum)

    -- tidy up interface
    updatesUI(line.."line", {
      text    = line,
      tooltip = "Click to change character",
      onClick = "scaddChar",
    })
    updatesUI(line.."charname", {
      active  = true,
      text    = charLib[lineNum].name,
      onClick = "scselectCharacter",
      --"<color="..person.color..">" .. firstToUpper(personcolour) .. " inactive</color>\n<color=#888888>l-click: </color>Assign colour\n<color=#888888>r-click:</color>Only show " .. personcolour
      --tooltip = charLib[lineNum].name .. ": " .. charLib[lineNum].currentColor .. ", click to select, right click to view",
      tooltip = "<color="..players[charLib[lineNum].currentColor].color..">"..firstToUpper(charLib[lineNum].currentColor) .. " player</color>\n<color=#888888>l-click: </color>Select\n<color=#888888>r-click:</color>View",
      color   = players[charLib[lineNum].currentColor].color,
    })
    updatesUI(line.."inputname", {
      selected = false,
      active   = false,
    })
    updatesUI(line.."active", {
      text        = crossMark,
      tooltip     = "Click to use in combat",
      onClick     = "scactiveChar",
      active      = true,
      combatState = false,
      fontStyle   = "Bold"
    })
end

function sclinkGUID(lineNum)
  if charLibGUID[lineNum] then
    local obj = getObjectFromGUID(charLibGUID[lineNum])
    if obj then
      charLib[lineNum].link = charLibGUID[lineNum]
      updateUI('BLKlinkName',"text",obj.getName())
      --log ("linking char link and obj guid.")
    else
      log("have a GUID for line number "..twodigitnumber(lineNum).." but cannot find object.")
    end
  end
end

function scnameFromMini(lineNum)
  if charLibGUID[lineNum] then
    local obj = getObjectFromGUID(charLibGUID[lineNum])
    if obj then
      if obj.getName() then -- it has a name, use it
        log("Using Mini Name '"..obj.getName().."' instead of JSON loaded name '"..charLib[lineNum].name.."'")
        charLib[lineNum].name = obj.getName()
      end
    else
      log("have a GUID for line number "..twodigitnumber(lineNum).." but cannot find object.")
    end
  end
end

function schandleCharacter(scgotName, content, line) -- Take the character from the get functions and configure it
  local hashInfo = ""
  -- get the #number and store it
  if string.match(scgotName, "(#[x]?%d+)") then
      hashInfo = string.match(scgotName, "(#[x]?%d+)")
  end
  -- no content found
  if content == "" then
      print("Did not find - " .. scgotName)
      return nil
  end
  -- replace Â½ with ½ and tidy content

  --local startTime=os.time()
  content = string.gsub(content, "Â½", "½")
  --content, changed = string.gsub(content, '"([^"]-)":', '%1=',1)

  content = string.gsub(content, "%[", "{")
  content = string.gsub(content, "%]", "}")
  content = string.gsub(content, "{", "${")
  --print ("Converting " .. scgotName)
  for i=1,#jsonKeyWords do
    content = string.gsub(content,'"'.. jsonKeyWords[i] .. '":', jsonKeyWords[i] .. '=')
  end
  content = string.gsub(content,'type=','["type"]=')
  content = string.gsub(content,'end=','["end"]=')

  --print("Regex on Character Duration = ", os.time()-startTime)
  -- 2022-Mar-13 - Commented out by Thirtybird
    --log (content)
  --print("String Replace Duration = ", os.time()-startTime)
  --load the json
  --local startTime = os.time()
  --local blah = JSON.decode(workingContent)
  --print("Json Decode Duration = ", os.time()-startTime)
  --local startTime = os.time()
  --dynamic.prepare(expr)
  --local stageCharacter = dynamic.prepare(content)
  --print("Dynamic Eval Prep Duration = ", os.time()-startTime)
  --local startTime = os.time()
  --local characterLoaded = copy(dynamic.eval(stageCharacter))
  --print("Dynamic Eval Duration = ", os.time()-startTime)
  --local startTime = os.time()
  local characterLoaded = copy(dynamic.eval(content))
  --print("Dynamic Eval Duration without prep = ", os.time()-startTime)
  --
  if characterLoaded.name then
      characterLoaded.originalName = copy(characterLoaded.name)
      characterLoaded.name = characterLoaded.name .. " " .. hashInfo
      characterLoaded.origin = copy(scgotName)
      print("Found - '" .. characterLoaded.name .. "'")
      --gotCharacter = true
      --character = characterLoaded
  else
      print("Invalid JSON content found in " .. scgotName)
  end
  -- Prepare and load rolls, skills and martial arts
  return scprepareCharacter(characterLoaded)
end

function scprepareCharacter(preparingCharacter) -- Take the character from handle character and create dice rolls
  local rollList = {}
  rollList[1] = {['name']='To Hit', ['halfDice']=false, ['killingAttack']=false, ['gameEdition']=6, ['dice']=3, ['level']=0, ['stunMultiplierMod']=0, ['diceMod']=0, ['targetNumber'] = 0, ['targetCheck']=false, ['tool']='3d6', ['tempMod'] = 0, ['toHit'] = true, ['useOCV'] = true, ['useDCV'] = true, ['useRanged'] = true, ['rangeMod'] = 0,}
  for key,value in pairs(preparingCharacter.rolls) do
      table.insert(rollList, value)
  end
  for stat,content in pairs(preparingCharacter.stats) do
      content.primary.origin = copy(content.primary.value)
      content.secondary.origin = copy(content.secondary.value)
      content.mod = 0
      --print (stat, logString(content) )
  end
  preparingCharacter.rollList = copy(rollList)
  for key,value in pairs(preparingCharacter.skills) do
    local oldName = copy(value.name)
    --preparingCharacter.skills[key].name=value.name .. iif(getNumber(value.level) > 0,"+" .. value.level .. " " .. value.optionAlias, value.roll)
    preparingCharacter.skills[key].name=value.name
    preparingCharacter.skills[key].halfDice=false
    preparingCharacter.skills[key].killingAttack=false
    preparingCharacter.skills[key].dice=3
    preparingCharacter.skills[key].level=tonumber(value.level)
    preparingCharacter.skills[key].diceMod=0
    preparingCharacter.skills[key].targetNumber=rollToNum(value.roll)
    preparingCharacter.skills[key].targetCheck=true
    preparingCharacter.skills[key].tool="Roll 3d6 for " .. oldName .. iif(value.roll=="","","and get ") .. iif(value.roll=="","",string.gsub(value.roll,"-"," or less") .. iif(value.familiarity or value.proficiency or value.everyman, " (" ..  iif(value.proficiency, "proficiency","") .. iif(value.everyman, "everyman","") .. iif(value.familiarity, iif(value.everyman, " ","") .. "familiarity","") .. ")",""))
    preparingCharacter.skills[key].targetBase = "num"
    if value.type then -- need to make change in
      if skillLookup[string.lower(value.type)] then
        --print("found ", string.lower(value.type), ", " , skillLookup[string.lower(value.type)].type,", " , skillLookup[string.lower(value.type)].stat  )
        if statOrder[skillLookup[string.lower(value.type)].stat] then -- check if this is a stat
          if not(value.proficiency or value.familiarity) then
            preparingCharacter.skills[key].targetBase = skillLookup[string.lower(value.type)].stat
          end
        elseif skillLookup[string.lower(value.type)].stat == "-" then
          preparingCharacter.skills[key].targetBase = "num"
        elseif tonumber(skillLookup[string.lower(value.type)].stat) then
          preparingCharacter.skills[key].targetBase = "num"
        end
      end
    end
  end
  if #preparingCharacter.martialArts > 1 then
    table.remove(preparingCharacter.martialArts,1)
    for key,value in pairs(mvr) do
        table.insert(preparingCharacter.martialArts, value)
    end
  else
    preparingCharacter.martialArts = copy(mvr)
  end
  if preparingCharacter.lightningReflex then
    if preparingCharacter.lightningReflex[1].levels == 0 then
      preparingCharacter.lightningReflex = nil
    else
      if #preparingCharacter.lightningReflex > 3 then
        for i = #preparingCharacter.lightningReflex,4,-1 do
          table.remove(preparingCharacter.lightningReflex,i)
        end
      end
    end
  else
    preparingCharacter.lightningReflex = nil
  end
  -- add status information to character
  preparingCharacter.status   = copy(status)
  preparingCharacter.counters   = {custom1 = 0, custom2 = 0, custom3 = 0}
  preparingCharacter.useOCV   = true
  preparingCharacter.link = ""
  previousNumberOfRolls = math.abs(currentNumberOfRolls)
  currentNumberOfRolls = currentNumberOfRolls + #preparingCharacter.rolls
  return preparingCharacter
end

function scactiveChar(player, state, id)
  --printArgs(player, state, id, "scactiveChar")
  local line = scgetLine(id)
  local lineNum = tonumber(line)
  if not(gatb(line.."active", "combatState")) then
    updatesUI(line.."active", {
      text      = checkMark,
      fontStyle = "Bold",
      onClick   = "scactiveChar",
      tooltip   = "Will use in combat",
      combatState = true,
    })
    addToCombat(line)
    ccreDrawByMode(CONST.showMsg) -- redraw whole combat interface (a bit wasteful, but easy)
  else
    scremoveCombatant(lineNum)
    ccreDrawByMode(CONST.showMsg)
    if #ccplayers < 1 then -- careful would need to count this if change to hash table of keys by guid
      endCombat(player,state,id)
    end
  end
end

function scgetLine(id) -- get the current line from the ID prefix
  return string.sub(id,1,2)
end

function scgotName(player, state, id) -- update the inputfield when the focus is lost
  updateUI(scgetLine(id).."inputname", "text", state)
end

function scloadBaseCharacter(inboundChar) -- Prepare the Base character to build the Browser windows with
    local test = copy(inboundChar)
    local startTime=os.time()

    --test = string.gsub(test, '":', '"=')
    test = string.gsub(test, [["([^"]-)":]], [[%1=]])
    test = string.gsub(test, "%[", "{")
    test = string.gsub(test, "%]", "}")
    test = string.gsub(test, "{", "${")
    test = string.gsub(test, 'end=', '["end"]=')
    test = string.gsub(test, 'type=', '["type"]=')



    --test = string.gsub(test, [["([^"]+)":]], [[%1=]])
    --test = string.gsub(test, "%[", "{")
    --test = string.gsub(test, "%]", "}")
    --test = string.gsub(test, "{", "${")
    --test = string.gsub(test, "end=", "['end']=")
    --test = string.gsub(test, "type=", "['type']=")
    --print("Regex on Base Character Duration = ", os.time()-startTime)
    --log(test)
    --local startTime=os.time()
    --bCharacter = JSON.decode(inboundChar)
    --print("Base Character Json Decode Duration = ", os.time()-startTime)
    --local startTime=os.time()
    bCharacter = copy(dynamic.eval(test))
    --print("Base Character Dynamic Eval Duration = ", os.time()-startTime)
    --local startTime=os.time()
    bCharacter = scprepareCharacter(bCharacter)
    --print("Base Character Prep Duration = ", os.time()-startTime)
end

-- [[

-- Character Browser Functions

-- ]]

function cbgetPlayerFromPre(pre) -- use the prefix to determine which player owned browser to update
  return players[preToCol[pre]]
end

function cbhideSection(player, value, id, build, thisSection) -- hide section of character browser
  -- section to hide is in value
  -- Hide a section once clicked on.
  --print("id: ", id)
  --print("value: ", value)
  -- over ride if thisSection specified
  -- will look like cbhideSection(player,-1,pre,false,"RollMaker")
  local textResult = gat(id, "text")
  if thisSection != nil then -- passed Section name i.e. RollMaker is thisSection
    textResult = thisSection
  end
  if textResult then
    textResult = removeWhiteSpace(textResult)
  end
  local pre = getPre(id)
  local playerInfo = {}
  if build then
    playerInfo.character = character
  else
    playerInfo = cbgetPlayerFromPre(pre)
  end
  local whichSection = iif (textResult,textResult,value)
  if getNumber(value) == -2 then
    local theChar = charLib[tonumber(playerInfo.viewing)]
    --print ("Right clicked Tab " .. textResult, " ID ", id )
    if whichSection == "Primary" then
      playerInfo.sections["Primary"].default = true
      playerInfo.sections["Secondary"].default = false
      -- problem here .. need to fix .. and set when character loaded into browser .. change primary or secondary based on character not current browser setting
      for _,statContent in pairs(theChar.stats) do
          statContent.current = "primary"
      end
    end
    if whichSection == "Secondary" then
      playerInfo.sections["Primary"].default = false
      playerInfo.sections["Secondary"].default = true
      -- problem here .. need to fix .. and set when character loaded into browser .. change primary or secondary based on character not current browser setting
      for _,statContent in pairs(theChar.stats) do
          statContent.current = "secondary"
      end
    end
    cbupdatePriSecTabs(playerInfo)
    -- Update visible skills to deal with stat change
    cbupdateSet(gat(pre.."skmod1","listIdx"), "skills", playerInfo)
    cbupdateHealth(pre, theChar)
  else
    sectionHidden = not(playerInfo.sections[whichSection].hidden) -- opposite current state
    for _,row in pairs(playerInfo.sections[whichSection].rows) do
        updateUI(pre..row, "active", not(sectionHidden))
    end
    playerInfo.sections[whichSection].hidden = sectionHidden

    local lines={}
    local countOnLine=0
    local countLines=1
    local lastSection = ""
    lines[countLines] = {}

    for key,section in pairs(playerInfo.sections) do
        lastSection = key
    end

    for key,section in pairs(playerInfo.sections) do
        countOnLine = countOnLine + 1
        table.insert(lines[countLines],key)
        if (countOnLine > 4) or (not(section.hidden)) then
            countOnLine = 0
            if key ~= lastSection then
                countLines = countLines + 1
                lines[countLines] = {}
            end
        end
    end

    for _,line in pairs(lines) do
        sectionLine = line[1]
        if playerInfo.sections[sectionLine].selfHidden then
            updateUI(pre..'sepRow'..line[1] , "active", true)
            playerInfo.sections[sectionLine].selfHidden = false
        end

        for i = 1,5 do
            sectionName = line[i]
            if sectionName ~= nil then
                --print("outline ", iif(playerInfo.sections[sectionName].default,"#FF0000","None"))
                attributeTable = {
                    text = playerInfo.sections[sectionName].name,
                    textShadow = "#000000",
                    onClick="cbhideSection",
                    colors='#222222|#444444|#222222|#222222',
                    textColor = iif(playerInfo.sections[sectionName].hidden,iif(playerInfo.sections[sectionName].default,'#8888DD','#888888'),iif(playerInfo.sections[sectionName].default,'#AAAAFF',"#CCCCCC")),
                    active = true,
                }
                updatesUI(pre..'sepHeader'.. i .. sectionLine, attributeTable)
                if i > 1 then
                    if not(playerInfo.sections[sectionName].selfHidden) then
                        updateUI(pre..'sepRow'..sectionName , "active", false)
                        playerInfo.sections[sectionName].selfHidden = true
                    end
                end
            else
                if gatb(pre..'sepHeader'.. i .. sectionLine, "active") then
                    updateUI(pre..'sepHeader'.. i .. sectionLine, "active", false) -- Got an empty tab so hide it
                end
            end
        end
    end
    if whichSection == "RollMaker" then
      cbrenotifyRM(pre, playerInfo.sections[whichSection].hidden)
    end
  end
end

function cbmakeHeadRow(pre,height, colour, newIDs) -- make a header row for a section of the character browser
    --local playerInfo = cbgetPlayerFromPre(pre) -- wrong!!
    local lineInfo = {}
    --if sectionHeader == "" then
      --  table.insert(lineInfo,{tag='Cell', attributes={columnSpan=25},children={{tag="Image", attributes={image="ui_line", type="filled", color="#333333"}}}})
    --else
        table.insert(lineInfo,{tag='Cell', attributes={columnSpan=5},children={{tag="Button", attributes={class='sepHeader', onClick="cbhideSection(" .. newIDs[1] ..")", id=pre..'sepHeader'.. "1" .. newIDs[1], text=sections[newIDs[1]].name,colors='#222222|#444444|#222222|#222222' }}}})
        table.insert(lineInfo,{tag='Cell', attributes={columnSpan=5},children={{tag="Button", attributes={class='sepHeader', onClick="cbhideSection(" .. newIDs[1] ..")", id=pre..'sepHeader'.. "2" .. newIDs[1] }}}})
        table.insert(lineInfo,{tag='Cell', attributes={columnSpan=5},children={{tag="Button", attributes={class='sepHeader', onClick="cbhideSection(" .. newIDs[1] ..")", id=pre..'sepHeader'.. "3" .. newIDs[1] }}}})
        table.insert(lineInfo,{tag='Cell', attributes={columnSpan=5},children={{tag="Button", attributes={class='sepHeader', onClick="cbhideSection(" .. newIDs[1] ..")", id=pre..'sepHeader'.. "4" .. newIDs[1] }}}})
        table.insert(lineInfo,{tag='Cell', attributes={columnSpan=5},children={{tag="Button", attributes={class='sepHeader', onClick="cbhideSection(" .. newIDs[1] ..")", id=pre..'sepHeader'.. "5" .. newIDs[1] }}}})
    --end
    return {tag='Row', attributes={id=pre..'sepRow'.. newIDs[1] ,class='sepRow'},children=lineInfo}
end

function cbgetStatTextName(stat,statState) -- generate a stat cell in the primary and secondary parts of the character browser
  return " " .. statOrder[stat.shortname].displayName
end

function cbgetStatTextValue(stat,statState) -- generate a stat cell in the primary and secondary parts of the character browser
  return iif(tonumber(stat[statState].value) == 0,figureSpace..figureSpace..figureDash..figureSpace,cbfigureSpacing(stat[statState].value)..figureSpace)
end

function cbgetStatTooltip(stat,statState) -- generate a stat cell in the primary and secondary parts of the character browser
  local lowStatState = string.lower(statState)
  --return statState .. " " .. stat.name ..": " .. stat[lowStatState].value .. iif(stat[lowStatState].roll ~= ""," (roll "..getRollFromStat(stat[lowStatState].value).."-) ", "")
  return statState .. " " .. stat.name ..": " .. stat[lowStatState].value .. " (roll " ..getRollFromStat(stat[lowStatState].value).."-) "
end

function cbstatCellName(stat,pre,statState) -- generate a stat cell in the primary and secondary parts of the character browser
  if stat then
    local lowStatState = string.lower(statState)
    return {tag='Cell', attributes={columnSpan=3},
      children={
        { tag='Text',
          attributes={
            onClick = iif(stat[lowStatState].roll ~= "",'cbdoRoll', ""),
            class   = 'statText',
            id      = pre..'statRoll' .. "n" .. string.sub(lowStatState, 1, 3) .. stat.shortname,
            text    = cbgetStatTextName(stat,lowStatState),
            --text    = " " .. string.upper(stat.shortname),
            color   = statOrder[stat.shortname].color,
            tooltip = cbgetStatTooltip(stat,statState),
          }
        }
      }
    }
  else
    return {tag='Cell', attributes={columnSpan=3}}
  end
end

function cbstatCellValue(stat,pre,statState) -- generate a stat cell in the primary and secondary parts of the character browser
  if stat then
    --print("stat ")
    --pl(stat[statVersion])
    local lowStatState = string.lower(statState)
    return {tag='Cell', attributes={columnSpan=3},
      children={
        { tag='Text',
          attributes={
            onClick = iif(stat[lowStatState].roll ~= "",'cbdoRoll', ""),
            class   = 'statText',
            id      = pre..'statRoll'.. "v" .. string.sub(lowStatState, 1, 3) .. stat.shortname,
            text    = cbgetStatTextValue(stat,lowStatState),
            --text    = iif(tonumber(stat[string.lower(statState)].value) == 0,figureSpace..figureSpace..figureDash,cbfigureSpacing(stat[string.lower(statState)].value)),
            color   = statOrder[stat.shortname].color,
            tooltip = cbgetStatTooltip(stat,statState),
          }
        }
      }
    }
  else
    return {tag='Cell', attributes={columnSpan=3}}
  end
end

function cbhideAtBuild(playerColor) -- Hide sections at build
  for key,section in pairs(players[playerColor].sections) do
    if not(section.hidden) then
        cbhideSection(playerColor, key, players[playerColor].prefix, false)
    end
  end
end

function cbhideGlobal(player, state, id) -- Hide Character Browser apart from Title bar
    local pre = getPre(id)
    local playerInfo = cbgetPlayerFromPre(pre)
    if getClick(state).left then
      hidden = not(hidden)
      for name,_ in pairs(playerInfo.sections) do
        if not(playerInfo.sections[name].selfHidden) then
          updateUI(pre..'sepRow'..name, "active", not(hidden))
        end
        if not(playerInfo.sections[name].hidden) then
          -- possibly alter the rows call to a numeric for loop .. using 1,section[name].numRows .. this could enable empty entries in rolls - which consequently enables no refresh on changing dice rolls or adding them
          for _,row in pairs(playerInfo.sections[name].rows) do
            updateUI(pre..row, "active", not(hidden))
          end
        end
      end
      -- Set the Tooltip
      cbrenotifyRM(pre, hidden)
    else
      for key,section in pairs(playerInfo.sections) do
        if not(section.hidden) then
          cbhideSection(player, key, pre)
        end
      end
    end
end

function cbhideBrowserUI(playerColor) -- No characters in pool, so hide browser after loading with base character
  local pre = players[playerColor].prefix
  updateUI(pre..'savedDiceRolls', "active", false)
  updateUI(pre..'panel', "active", false)
end

function cbfigureSpacing(number)
  local holdNum = tostring(number)
  local totalLen = 3 - string.len(holdNum)
  if totalLen > 0 then
    holdNum = string.rep(figureSpace, totalLen) ..  holdNum
  end
  return holdNum
end

function cbupdatePoolInfo(playerInfo)
  local pre = playerInfo.prefix
  local theChar = charLib[tonumber(playerInfo.viewing)]
  if pre != "BLA" then
    local charactersInPool = scgetCharactersByColor(string.lower(playerInfo.desc))
    updateUI(pre..'poolPrevious', 'active', true)
    updateUI(pre..'poolNext', 'active', true)
    updateUI(pre..'poolNumber', 'active', true)
    local listOfNames = "Characters: "
    local currentName = 0

    for i = 1, #charactersInPool do
      listOfNames = listOfNames .. charactersInPool[i].name .. iif(i != #charactersInPool, ", ", "" )
      if charactersInPool[i].name == theChar.name then
        currentName = i
      end
    end
    updatesUI(pre..'poolNumber',{
      active = true,
      text = currentName .. "/" .. #charactersInPool,
      tooltip = listOfNames,
    })
  else
    --print ("Got here")
    updateUI(pre..'poolPrevious', 'active', false)
    updateUI(pre..'poolNext', 'active', false)
    updateUI(pre..'poolNumber', 'active', false)
  end
end

function cbupdateTitle(playerInfo)
  local pre = playerInfo.prefix
  local theChar = charLib[tonumber(playerInfo.viewing)]
  local colorToShow = iif(pre == "BLA", players[theChar.currentColor].color ,  playerInfo.color  )
  local theTooltip = string.format ("<color=%s>%s</color>\n<color=#888888>l-click:\t</color>Minimise / reveal browser\n<color=#888888>r-click:</color>\tClose / open all tabs\n<color=#888888>drag:\t</color>Move browser", colorToShow, theChar.name)
  local titleTable = checkUpdates({ id = pre..'title', checks = {
    text       = " " .. theChar.name .. " " .. cbccgetStatusString(true, playerInfo),
    color      = colorToShow,
    tooltip    = theTooltip,
  }})

  if next(titleTable) then
    updatesUI(pre..'title',titleTable)
  end
end

function cbupdatePriSecTabs(playerInfo)
  local pre = playerInfo.prefix
  local theChar = charLib[tonumber(playerInfo.viewing)]
  updateUI(pre.."sepHeader1Primary" , "textColor", iif(playerInfo.sections["Primary"].hidden,iif(playerInfo.sections["Primary"].default,'#8888DD','#888888'),iif(playerInfo.sections["Primary"].default,'#AAAAFF',"#CCCCCC")))
  updateUI(pre.."sepHeader2Primary" , "textColor", iif(playerInfo.sections["Secondary"].hidden,iif(playerInfo.sections["Secondary"].default,'#8888DD','#888888'),iif(playerInfo.sections["Secondary"].default,'#AAAAFF',"#CCCCCC")))
  updateUI(pre.."sepHeader1Secondary" , "textColor", iif(playerInfo.sections["Secondary"].hidden,iif(playerInfo.sections["Secondary"].default,'#8888DD','#888888'),iif(playerInfo.sections["Secondary"].default,'#AAAAFF',"#CCCCCC")))
end

function cbgetPrimary(playerInfo)
  local theChar = charLib[tonumber(playerInfo.viewing)]
  if theChar.stats.str.current == "primary" then
    return true
  else
    return false
  end
end

function cbreDrawUI(playerInfo, showBrowser) -- update and show new character in player Character Browser
  --print ("Redrawing: ", playerInfo.character.name)
    if showBrowser == nil then -- default to show
      showBrowser = true
    end
    local pre = playerInfo.prefix
    local theChar = charLib[tonumber(playerInfo.viewing)]
    -- nameRow
    cbupdateTitle(playerInfo)
    cbupdatePoolInfo(playerInfo)
    for _,statState in pairs({"Primary","Secondary"}) do
      for key,value in pairs(statOrder) do
        if key != "blank" then
          local stat = theChar.stats[key]
          updatesUI(pre..'statRoll' .. "n" .. string.lower(string.sub(statState, 1, 3)) .. key,{
            text = cbgetStatTextName(stat, string.lower(statState)),
            tooltip = cbgetStatTooltip(stat,statState),
          })
          updatesUI(pre..'statRoll' .. "v" .. string.lower(string.sub(statState, 1, 3)) .. key,{
            text = cbgetStatTextValue(stat, string.lower(statState)),
            tooltip = cbgetStatTooltip(stat,statState),
          })
        end
      end
    end

    local isPrimaryCurrent = cbgetPrimary(playerInfo)
    playerInfo.sections["Primary"].default = isPrimaryCurrent
    playerInfo.sections["Secondary"].default = not(isPrimaryCurrent)
    cbupdatePriSecTabs(playerInfo)

    for i,moveType in pairs({"run","swim","leap","fly","glide","swing","teleport","tunnel"}) do
        if theChar.movement[moveType] then
            updatesUI(pre..moveType, {
                active = iif(theChar.movement[moveType],true,false),
                image = theChar['movement'][moveType]['icon'],
                tooltip = moveType .. ": ".. theChar['movement'][moveType]['combat'] .. " / ".. theChar['movement'][moveType]['noncombat'],
            })
        else
            updateUI(pre..moveType, 'active', iif(theChar.movement[moveType],true,false))
        end
    end
    cbupdateSet(1, "skills",playerInfo)
    cbupdateSet(1, "martialArts",playerInfo)
    cbreDrawRolls(playerInfo)

    -- redraw combat

    if theChar.lightningReflex then
        for i = 1,#theChar.lightningReflex do
            updatesUI(pre.."reflexMod"..i,{
                text = theChar.lightningReflex[i].name,
                tooltip = theChar.lightningReflex[i].tool,
                active = true,
            })
        end

        if #theChar.lightningReflex < 3 then
            for i = #theChar.lightningReflex + 1,3 do
                updatesUI(pre.."reflexMod"..i,{
                    text = "",
                    tooltip = "",
                    active = false,
                })
            end
        end

        --print ("character.lightningReflex was ", logString(character.lightningReflex))
        updateUI(pre.."lreflex", 'active', true )
        updateUI(pre.."titleReflex", 'active', true)
        updateUI(pre.."combatRow1", 'preferredHeight', (#theChar.lightningReflex*34)+34)
    else
        updateUI(pre.."lreflex", 'active', false)
        updateUI(pre.."titleReflex", 'active', false)
        updateUI(pre.."combatRow1", 'preferredHeight', 1)
    end

    for i = 1,#theChar.status do
        updateUI(pre..'statusMod'..i, "isOn", theChar.status[i].isActive)
        if theChar.status[i].isCustom then
          -- deal with custom entries
          updatesUI(pre..'statusMod'..i,{
            text = theChar.status[i].name,
            tooltip = theChar.status[i].tool,
          })
        end
    end

    cbupdateHealth(pre, theChar)

    --[[
    if theChar.link != "" then
      local gotObj = getObjectFromGUID(theChar.link)
      if gotObj then
        updateUI(pre.."linkName", 'text', gotObj.getName())
      else
        updateUI(pre.."linkName", 'text', "")
      end
    else
      updateUI(pre.."linkName", 'text', "")
    end
    --]]
    if cbgetLinkedObj(theChar) then
      updateUI(pre.."linkName", 'text', cbgetLinkedObj(theChar).getName())
    else
      updateUI(pre.."linkName", 'text', "")
    end


    -- do there last to reduce refresh times
    updateUI(pre..'savedDiceRolls', "active", showBrowser)
    updateUI(pre..'panel', "active", showBrowser)
end

function cbgetLinkedObj(theChar)
  if theChar.link != "" then
    local gotObj = getObjectFromGUID(theChar.link)
    if gotObj then
      return gotObj
    else
      return nil
    end
  else
    return nil
  end
end

function cbupdateHealth(pre, theChar)
  local playerInfo = cbgetPlayerFromPre(pre)
  for i,stat in pairs({"body","stun","end"}) do
    local upperStat = firstToUpper(stat)
    updateUI(pre..'text' ..upperStat, "text", " "..upperStat.. " (" .. getStatOrigin(theChar.stats, stat) .. ")")
    updateUI(pre..'input'..upperStat, "text", getStatValue(theChar.stats, stat))
  end
  --if cccombatmode then
    ccamendHealth(playerInfo.viewing)
  --end
  for i = 1,3 do
    updateUI(pre..'inputCustom'..i, "text", theChar.counters["custom"..i])
  end
end

function cboriginStat(player,state,id)
  --printArgs(player, state, id, "cboriginStat")
  if getClick(state).right then
    local pre = getPre(id)
    local playerInfo = cbgetPlayerFromPre(pre)
    local theChar = charLib[tonumber(playerInfo.viewing)]
    local stat = string.lower(string.sub(id,8))
    --print (getStatOrigin(theChar.stats, stat))
    theChar.stats[stat].mod = 0
    cbupdateHealth(pre, theChar)
  end
end

function cbChangeNum(player,state,id)
  --printArgs(player, state, id, "cbChangeNum")
  local modifyamount = iif(getClick(state).right, 5,1)
  local pre = getPre(id)
  local playerInfo = cbgetPlayerFromPre(pre)
  local theChar = charLib[tonumber(playerInfo.viewing)]
  local action = string.sub(id,6,10)
  local multiplyer = iif(action=="lower",-1,1)
  local target = string.sub(id,11)
  local amount = gatn(pre.."input"..target,"text")
  local result = tonumber(amount + (multiplyer * modifyamount))
  --print("Character: ", theChar.name ,", target: ", target, ", action: ",action)
  --updateUI(pre.."input"..target,"text", result)
  if (target == "Body") or (target == "Stun") or (target == "End") then
    --print ("The modifier would be ", result - tonumber(theChar.stats[string.lower(target)].primary.origin) + theChar.stats[string.lower(target)].mod )
    theChar.stats[string.lower(target)].mod = theChar.stats[string.lower(target)].mod + (multiplyer * modifyamount)
    --print ("Modifier is now ", theChar.stats[string.lower(target)].mod )
  else
    theChar.counters[string.lower(target)] = result
  end
  cbupdateHealth(pre, theChar)
end

function cbeditCounter(player,state,id)
  --printArgs(player, state, id, "cbeditCounter")
  local pre = getPre(id)
  local playerInfo = cbgetPlayerFromPre(pre)
  local theChar = charLib[tonumber(playerInfo.viewing)]
  local stat = string.lower(string.sub(id,9))
  local amount = getNumber(state)
  if (stat == "body") or (stat == "stun") or (stat == "end") then
    local difference = amount - (getStatOrigin(theChar.stats, stat) + getStatMod(theChar.stats, stat))
    theChar.stats[stat].mod = theChar.stats[stat].mod + difference
    --print(id, ": amount " .. amount .. ", difference ", difference, ", origin ", getStatOrigin(theChar.stats, stat), ", ", getStatMod(theChar.stats, stat) )
  else
    theChar.counters[stat] = amount
  end
  cbupdateHealth(pre, theChar)
end

function cbreDrawRolls(playerInfo) -- redraw Rolls UI, can be done without full UI Redraw
    -- DR
    local pre = playerInfo.prefix
    local theChar = charLib[tonumber(playerInfo.viewing)]
    updatesUI(pre.."diceRow", {
        height = (math.min(#theChar.rollList,5)*34)+5,
        preferredHeight =(math.min(#theChar.rollList,5)*34)+5,
    })
    updatesUI(pre.."diceTable",{
        height = #theChar.rollList*34,
        preferredHeight =#theChar.rollList*34,
    })
    -- load rollList
    for i,diceRolls in ipairs(theChar.rollList) do
        local iconToUse="ui_dice"
        local iconTip = "Normal Roll"
        if diceRolls.toHit then
            iconToUse = "Sprites/Icons/Crosshair"
            iconTip = "To Hit Roll"
        elseif diceRolls.killingAttack then
            iconToUse = "ui_skull"
            iconTip = "Killing Roll"
        elseif diceRolls.targetCheck then
            iconToUse = "ui_target"
            iconTip = "Target Roll"
        end
        updateUI(pre..'Row'..i, "active", "true")
        updatesUI(pre..'edit'..i, {
            image = iconToUse,
            tooltip = iconTip,
        })
        updateUI(pre..'saveMod'..i , "text", 0)
        updatesUI(pre..'rollSave'..i,{
            text = diceRolls.name,
            tooltip = diceRolls.tool,
            textColor = "#CCCCCC",
        })
    end

    local numToDo = 0

    if currentNumberOfRolls < previousNumberOfRolls then
        numToDo = previousNumberOfRolls - currentNumberOfRolls
    end

    if numToDo > 0 then
        for i = #theChar.rollList+1,#theChar.rollList+1+numToDo do
            updateUI(pre..'Row'..i, "active", "false")
            updateUI(pre..'edit'..i, "image", "ui_dice")
            updateUI(pre..'saveMod'..i , "text", 0)
            updatesUI(pre..'rollSave'..i,{
                text = "",
                tooltip = "",
                textColor = "#CCCCCC",
            })
        end
    end
end

function cbsetChange(player,state,id) -- change current dataset (skills/martial arts)
  local pre = getPre(id)
  local playerInfo = cbgetPlayerFromPre(pre)
  local theChar = charLib[tonumber(playerInfo.viewing)]
  local numOfRows = 3
  local list =  gat(id, "list")
  local listIdx = gatn(id, "listIdx")
  local rowIdx = gatn(id, "row")
  local numSets = math.ceil(#theChar[list] / numOfRows)
  local startIdx = 0
  if getClick(state).right then
      startIdx = iif(rowIdx==1, 1, (numSets * numOfRows)-2 )
  else
      startIdx = iif(rowIdx==1,listIdx - numOfRows, listIdx + 1)
  end
  cbupdateSet(startIdx, list, playerInfo)
end

function cbupdateSet(startIdx, list, playerInfo) -- update set data (skills/martial arts)
  local pre = playerInfo.prefix
  local theChar = charLib[tonumber(playerInfo.viewing)]
  local numOfRows, currentRow = 3, 1
  local numSets = math.ceil(#theChar[list] / numOfRows)
  local currentSet = math.ceil(startIdx / numOfRows)
  if list == "skills" then shortList = "sk" end
  if list == "martialArts" then shortList = "ma" end
  for i = startIdx, startIdx+numOfRows-1 do
      if i <= #theChar[list] then
          local theRoll = theChar[list][i]
          local currentRoll = cbGetSkillRoll(theRoll,playerInfo)
          if currentRoll == 0 then
            if tonumber(theRoll.level) > 0 then
              currentRoll = "+" .. theRoll.level
            else
              currentRoll = ""
            end
          end
          if list=="skills" then
            toolText = "Roll 3d6 for " .. theRoll.name ..
            iif(currentRoll=="" or currentRoll==0,"","and get ") ..
            iif(currentRoll==""  or currentRoll==0,"",currentRoll .. " or less") ..
            iif(theRoll.familiarity or theRoll.proficiency or theRoll.everyman, " (" ..  iif(theRoll.proficiency, "proficiency","") .. iif(theRoll.everyman, "everyman","") .. iif(theRoll.familiarity, iif(theRoll.everyman, " ","") .. "familiarity","") .. ")","")
          else
            toolText = theRoll.tool
          end
          showFlag = true
          thisName = theRoll.name .. iif(list == "skills", " " .. currentRoll .. iif((currentRoll == "") or (string.sub(currentRoll,1,1) == "+"),"","-"),"")

      else
          toolText,thisName,showFlag = "", "",false
      end
      --pre.."skmod1" listIdx
      updatesUI(pre..shortList .. "desc"..currentRow, {active = showFlag,text = ' ' .. thisName,listIdx = i,tooltip = toolText})
      updatesUI(pre..shortList .. "mod" ..currentRow, {active = showFlag,listIdx = i,text = 0,tooltip = "Enter a dice modifier for the "..thisName .. " roll"})
      updatesUI(pre..shortList .. "img" ..currentRow, {active = showFlag,listIdx = i,tooltip = toolText})
      currentRow = currentRow + 1
  end
  -- up goes on first line, down on last of numOfRows .. with (numOfRows +1) / 2 for the numbers
  updatesUI(pre..shortList .. "ctlimg1", {tooltip = "Previous set " .. (currentSet - 1) .. " of " .. numSets,listIdx = startIdx,active = iif(currentSet>1,true,false)})
  updatesUI(pre..shortList .. "ctltxt".. ((numOfRows + 1) / 2), {tooltip = "Set ".. currentSet .. " of " .. numSets,listIdx = startIdx+1,text = currentSet .. "/" .. numSets})
  updatesUI(pre..shortList .. "ctlimg"..numOfRows, {tooltip = "Next set " .. (currentSet + 1) .. " of " .. numSets,listIdx = startIdx+2,active = iif(currentSet>=numSets,false,true)})
end

function cbtoggleOCV(player,state,id) -- Toggle between use of OCV and OMCV
  -- Very broken need to be rewritten
  local pre = getPre(id)
  local playerInfo = cbgetPlayerFromPre(pre)
  local theChar = charLib[tonumber(playerInfo.viewing)]
  theChar.useOCV = not(theChar.useOCV)
  --local useOCV = playerInfo.character.useOCV
  updatesUI(pre..'ocvStatName', {
      text = ' CV    \t' .. theChar.ocv.value .. "/" .. theChar.dcv.value .. iif(theChar.useOCV,"•",""),
      tooltip = "OCV / DCV: " ..  theChar.ocv.value .. "/" .. theChar.dcv.value .. iif(theChar.useOCV," - selected for Attacks",""),
  })
  updatesUI(pre..'omcvStatName', {
      text = ' MCV  \t' .. theChar.omcv.value .. "/" .. theChar.dmcv.value .. iif(not(theChar.useOCV),"•",""),
      tooltip = "OMCV / DMCV: " ..  theChar.omcv.value .. "/" .. theChar.dmcv.value .. iif(not(theChar.useOCV)," - selected for Attacks",""),
  })
end

function cbNextInPool(player,state,id) -- Change to the next character in the pool
  cbChangeInPool(player,state,id,1)
end

function cbPrevInPool(player,state,id) -- Change to the next character in the pool
  cbChangeInPool(player,state,id,-1)
end

function cbChangeInPool(player,state,id,direction) -- Change to the next character in the pool
  --print ("Got here Player: ", player, ", state: ", state, ", id: ", id, ", direction: ", direction)
  local pre = getPre(id)
  local playerInfo = cbgetPlayerFromPre(pre)
  local theChar = charLib[tonumber(playerInfo.viewing)]
  local charactersInPool = scgetCharactersByColor(string.lower(playerInfo.desc))

  local characterPositionInPool = 0
  local newPosition = 0
  for i = 1,#charactersInPool do
    if theChar.name == charactersInPool[i].name then
      characterPositionInPool = i
      break
    end
  end
  if characterPositionInPool > 0 then
    newPosition = characterPositionInPool + direction
    if newPosition == 0 then -- loop around from 0 to max
      newPosition = #charactersInPool
    end
    if newPosition > #charactersInPool then -- loop around from max+1 to 1
      newPosition = 1
    end
  else
    --print("Got here 2")
    return false
  end
  scchangeCharacterInBrowser(string.lower(playerInfo.desc), charactersInPool[newPosition].line)
end

function cbmoveSelection(player, value, id) -- Toggle between movement types
  -- should store in the character which is current .. do later
  local pre = getPre(id)
  for key,moveType in pairs({"run","swim","leap","fly","glide","swing","teleport","tunnel"}) do
      if moveType == value then
          updateUI(pre..moveType, "color", "#BBFFBBFF")
      else
          updateUI(pre..moveType, "color", "#66666666")
      end
  end
end

function cbupdateDist(player,state,id) -- update a or b field in distance tab
    local pre = getPre(id)
    updateUI(id, "text", getNumber(state))
    Wait.frames(function() cbupdatePythag(pre) end, 1)
end

function cbreverseupdateDist(player,state,id) -- -- update c field in distance tab
    local pre = getPre(id)
    updateUI(id, "text", getNumber(state))
    Wait.frames(function() cbupdateReversePythag(pre) end, 1)
end

function cbupdatePythag(pre) -- Calculate hypotenuse for distance
    local width  = gatn(pre..'statWidthMod',  "text")
    local height = gatn(pre..'statHeightMod', "text")
    local distance = math.ceil(math.sqrt((height * height) + (width * width)))
    local rm = cbgetRangeMod(distance)
    updatesUI(pre .. 'pythagMod', {
        text = distance,
        tooltip = "Distance <i>'cs'</i>  in Metres " .. distance .. ", (" .. rm.below .. " < "..distance.." < "..rm.above..")",
    } )
    updatesUI(pre .. 'rangeMod', {
        text = rm.rangeModifier,
        tooltip = iif( gatb(pre.."rangeMod", "isOn"),"Stop using", "Use") .. " range modifier of " .. rm.rangeModifier .. "?",
    })
    return distance
end

function cbupdateReversePythag(pre)  -- Calculate from hypotenuse for distance
    local width  = gatn(pre..'statWidthMod',  "text")
    local height = gatn(pre..'statHeightMod', "text")
    local pythag = gatn(pre..'pythagMod', "text")
    if (width == 0) and (height == 0) then
        updateUI(pre..'statWidthMod', "text", pythag)
    elseif (width == 0) and (height > 0) then
        width = math.floor(math.sqrt(math.abs((pythag * pythag) - (height * height)))+0.5)
        updateUI(pre..'statWidthMod', "text", width)
    elseif (width > 0) and (height == 0) then
        height = math.floor(math.sqrt(math.abs((pythag * pythag) - (width * width)))+0.5)
        updateUI(pre..'statHeightMod', "text", height)
    end
    Wait.frames(function() cbupdatePythag(pre) end, 1)
end

function cbgetRangeMod(dist) -- calculate range modifier upto 1 million meters
    local rangemod
    local ranges = {0,1,8,12,16,24,32,48,64,96,128,192,256,384,512,768,1024,1536,2048,3072,4096,6144,8192,12288,16384,24576,32768,49152,65536,98304,131072,196608,262144,393216,524288,786432,1048576}
    for i,range in pairs(ranges) do
        if dist <= range then
            rangemod = i
            break
        end
    end
    return {rangeModifier = math.max(rangemod-3,0)*-1, below = ranges[math.max(math.abs(rangemod)-1,1)], above = ranges[math.min(math.abs(rangemod),#ranges)]+1}
end

function cbdoRoll(player,state,id,theRoll) -- make a dice roll using a diceroller
    local pre = getPre(id)
    local playerInfo = cbgetPlayerFromPre(pre)
    local theChar = charLib[tonumber(playerInfo.viewing)]

    local click = getClick(state)
    local rollToSend = {}
    local rollOrigin = string.sub(id,4,9)
    if rollOrigin == "rollSa" then -- Dice Rolls Section
        rollToSend = copy(theChar.rollList[getNumber(string.sub(id,12))])
        rollToSend.tempMod = gatn(pre..'saveMod'..getNumber(string.sub(id,12)), "text")
    elseif rollOrigin == "statRo" then -- Primary or Secondary Rolls section
        local statToRoll = string.sub(id,16)
        local stateOfRoll = iif(string.sub(id,13,15) == "pri", "primary", "secondary")
        local theRoll = getRollFromStat(theChar.stats[statToRoll][stateOfRoll].value)
        rollToSend = {
          name=firstToUpper(stateOfRoll) .. " ".. theChar.stats[statToRoll].name .. " " .. theRoll .. "-",
          targetBase = statToRoll,
          tempMod = 0,
          targetNumber = theRoll,
          halfDice=false, dice=3, diceMod=0, targetCheck=true, tool='', print = iif(getNumber(state) == -2, false, true),
        }
    elseif rollOrigin == "skdesc" then -- Skills section - needs reworking to get STAT
        rollToSend = copy(theChar.skills[gatn(id, "listIdx")])
        rollToSend.tempMod = gatn(pre..'skmod'..gatn(id, "row"), "text")
    elseif rollOrigin == "madesc" then -- Maneuver Section
        rollToSend = copy(theChar.martialArts[gatn(id, "listIdx")])
        rollToSend.tempMod = gatn(pre..'mamod'..gatn(id, "row"), "text")
    elseif rollOrigin == "locati" then -- Rolling on Location target
        rollToSend = currentLocation
        rollToSend.toHit = false
        rollToSend.tempMod=gatn(pre.."statLocationMod","text")
    elseif theRoll != nil then -- any other invoked roll (from RollNow)
        rollToSend = theRoll
    end

    local rollpad = getObjectFromGUID(playerInfo.roller)
    -- load common values into rollToSend
    rollToSend.color = playerInfo.desc
    rollToSend.playerName = theChar.name

    if rollToSend.useOCV == nil then -- has useOCV been set previously, if so honour it else use current selection
      rollToSend.useOCV = theChar.useOCV
    end
    if not(rollToSend.ocvMod) then -- is there an existing ocvMod, if so use it if not set to zero
      rollToSend.ocvMod = 0
    end

    if not(rollToSend.OCV) then -- has the ocv / omcv been sent .. if so use it.
      if rollToSend.useOCV then -- check if OCV or OMCV .. if nothing sent grab current
        local OCVStat = theChar.stats.ocv
        rollToSend.OCV = OCVStat[OCVStat.current].value
      else
        local OMCVStat = theChar.stats.omcv
        rollToSend.OCV = OMCVStat[OMCVStat.current].value
      end
    end

    if rollToSend.toHit then -- TO HIT ROLL
      --print("rollToSend.ocvMod ",rollToSend.ocvMod, ". rollToSend.tempMod ", rollToSend.tempMod)
      local rangeCalc = iif(gatb(pre.."rangeMod","isOn"),gatn(pre.."rangeMod","text"),0)
      --print ("rollToSend.rangeMod ", rollToSend.rangeMod)
      --print ("rollToSend.useRanged ", rollToSend.useRanged)
      if rollToSend.useRanged then
        rangeCalc = math.min(iif(gatb(pre.."rangeMod","isOn"),gatn(pre.."rangeMod","text"),0) + rollToSend.rangeMod, 0)
        --print ("rangeCalc ", rangeCalc)
      else
        --print ("Reached here")
        rangeCalc = 0
      end
      rollToSend.ocvMod = rollToSend.ocvMod + rollToSend.tempMod + rangeCalc
      rollToSend.tempMod = 0
    elseif rollToSend.targetCheck then -- TARGET ROLL
      if rollToSend.targetBase != "num" then
        --print ("targetBase ", rollToSend.targetBase)
        local whichStat = theChar.stats[rollToSend.targetBase]
        if rollOrigin != "statRo" then -- add source of roll to name
          rollToSend.targetNumber = getRollFromStat(whichStat[whichStat.current].value)
        end
        if rollOrigin == "skdesc" then -- add source of roll to name
          -- override target number if everyman skill
          rollToSend.targetNumber = iif(rollToSend.everyman, 8, rollToSend.targetNumber)
          rollToSend.targetNumber = rollToSend.targetNumber + rollToSend.level
          rollToSend.name = rollToSend.name .. " (" .. firstToUpper(whichStat.current) .. " ".. whichStat.name .. ")"
        end
        local currentStatChoice = theChar.stats[rollToSend.targetBase].current
        --rollToSend.targetNumber = iif(toSave, -1, rollToNum(playerInfo.character.stats[rollToSend.targetBase][currentStatChoice].roll))
      end
      rollToSend.targetNumber = math.max(rollToSend.targetNumber + iif(rollToSend.targetMod, rollToSend.targetMod, 0) + rollToSend.tempMod,0)
      --rollToSend.targetNumber = math.max(rollToSend.targetNumber,0)
      --rollToSend.tempMod = iif(rollToSend.targetMod, rollToSend.targetMod, 0) + rollToSend.tempMod
      rollToSend.tempMod = 0
    end

    rollToSend.print = iif(click.right, false, true)

    rollpad.call("extCall", rollToSend)
end

function cbupdateChangeMod(player,state,id) -- update the modifier field in changes
  local whichStat = gat(id,"whichStat")
  if whichStat == "spd" then
      state = math.min(math.abs(getNumber(state)),12)
  else
      state = math.abs(getNumber(state))
  end
  state = math.max(state,1)
  updateUI(id,"text",state)
end

function cbrestoreStat(player,state,id) -- restore stat from original
  local pre = getPre(id)
  local playerInfo = cbgetPlayerFromPre(pre)
  local theChar = charLib[tonumber(playerInfo.viewing)]
  local whichStat = gat(id,"whichStat")
  if theChar[whichStat].original ~= nil then
      theChar[whichStat].value = getNumber(theChar[whichStat].original)
      theChar[whichStat].roll = math.floor( (9 + (theChar[whichStat].value/5))+0.5) .. "-"
      updateUI(pre.."statChange","text",getNumber(theChar[whichStat].original))
      theChar[whichStat].original = nil
      -- Need to change when COMBAT controller is active. Might not need too .. might just need to force refresh
--[[
      params = { guid = self.guid, stat = whichStat, value = playerInfo.character[whichStat].value,}
      masterControl.call("ccamendStats",params)
      Wait.frames(cbreDrawUI,1)
--]]
  end
end

function cbchangeStat(player,state,id) -- change stat
    --print("cbchangeStat Player: ",player,"State: ", state,"ID: ",id)
    local pre = getPre(id)
    local playerInfo = cbgetPlayerFromPre(pre)
    local theChar = charLib[tonumber(playerInfo.viewing)]
    local whichStat = gat(id,"whichStat")
    local statNewValue = gatn(pre.."statChange","text")
    print ("First Whichstat = ", whichStat, ", value = ", statNewValue, ", roll = ", theChar[whichStat].roll, ", original = " , iif(theChar[whichStat].original,theChar[whichStat].original,"now nil"))

    if getNumber(theChar[whichStat].value) ~= statNewValue then
      if theChar[whichStat].original == nil then
          -- Set original if unknown
          theChar[whichStat].original = getNumber(copy(theChar[whichStat].value))
      elseif getNumber(theChar[whichStat].original) == statNewValue then
          -- player has restored stat so set original to nil
          theChar[whichStat].original = nil
      end
      print ("Second Whichstat = ", whichStat, ", value = ", statNewValue, ", roll = ", theChar[whichStat].roll, ", original = " , iif(theChar[whichStat].original,theChar[whichStat].original,"now nil"))
      --update different stat
      theChar[whichStat].value = statNewValue
      -- need to recalc roll
      theChar[whichStat].roll = math.floor( (9 + (statNewValue/5))+0.5) .. "-"
        -- Need to rewrite this section when combat controller is written - might just need to refresh
--[[
        params = { guid = self.guid, stat = whichStat, value = statNewValue,}
        print ("About to ccamendStats", logString(params))
        masterControl.call("ccamendStats",params)
--]]
      cbreDrawUI(playerInfo)
    end
end

function cbgetChange(player,state,id) -- update change buttons and entries
    --print("Player: ",player,"State: ", state,"ID: ",id)
    --print("Chosen: "..string.sub(state, 1, string.find(state, " :")-1))
    --local selectedStat = string.sub(state, 1, string.find(state, " :")-1)
    local pre = getPre(id)
    local playerInfo = cbgetPlayerFromPre(pre)
    local theChar = charLib[tonumber(playerInfo.viewing)]
    local selectedStat = state
    local selectedStatShort = ""
    local selectedStatValue = 0
    for i,stat in pairs(statList) do
        if (theChar[stat].name) == selectedStat then
            --print(character[stat].name)
            selectedStatShort = theChar[stat].shortname
            selectedStatValue = theChar[stat].value
            break
        end
    end
    --print ("Selected Stat: ", selectedStat, ", ", selectedStatShort, ", Value: ",selectedStatValue)
    updatesUI(pre.."statChange", {
        text = selectedStatValue,
        whichStat = selectedStatShort,
    })
    updatesUI(pre.."cbrestoreStat", {
        text = "Restore " .. string.upper(selectedStatShort) ,
        whichStat = selectedStatShort,
        tooltip = "Click to restore " .. theChar[selectedStatShort].name .. " to original value",
    })
    updatesUI(pre.."cbchangeStat", {
        whichStat = selectedStatShort,
        tooltip = "Click to change " .. theChar[selectedStatShort].name .. " to entered value",
    })
end

function cbsetLocation(player,state,id) -- get the current location chart
  local pre = getPre(id)
  for i,location in pairs(locationTables) do
      if (location.name) == state then
          currentLocation = location
      end
  end
  updateUI(pre..'locationDrop', "tooltip", currentLocation.tool)
end

function cbupdateRangeMod(player, state, id)
    rangeModIsOn = getBool(state)
    updatesUI(id, {
        isOn = rangeModIsOn,
        tooltip = iif(rangeModIsOn,"Stop using", "Use") .. " range modifier of " .. gatn(id, "text") .. "?",
    })
end

function cbupdateReflexMod(player,state,id) --
  local pre = getPre(id)
  local playerInfo = cbgetPlayerFromPre(pre)
  local theChar = charLib[tonumber(playerInfo.viewing)]
  local whichLR = tonumber(string.sub(id,13))
  updateUI(id, "isOn", getBool(state),true)
  theChar.lightningReflex[whichLR].isActive = getBool(state)
  ccamendReflex(playerInfo.viewing)
end

function cbupdateStatusMod(player,state,id) --
  local pre = getPre(id)
  local playerInfo = cbgetPlayerFromPre(pre)
  local theChar = charLib[tonumber(playerInfo.viewing)]
  updateUI(id, "isOn", getBool(state))
  local whichStatus = tonumber(string.sub(id,13,13))
  local output = ""
  if (whichStatus >= 2) and (whichStatus <= 4) then
    for i = 2,4 do
      if theChar.status[i].isActive and not(whichStatus == i) then
        updateUI(pre..'statusMod'..i, "isOn", false)
        theChar.status[i].isActive = false
        output = theChar.status[i].seguePost
        print (theChar.name .. " " .. theChar.status[i].finishPost )
      end
    end
  end
  theChar.status[whichStatus].isActive = getBool(state)
  print (theChar.name .. " " .. output .. iif (theChar.status[whichStatus].isActive, theChar.status[whichStatus].startPost,theChar.status[whichStatus].finishPost) )
  updateUI(pre..'title', "text", theChar.name .. " " .. cbccgetStatusString(true, playerInfo))
  ccamendStatus(playerInfo.viewing)
end

function cbccgetStatusString(withBrackets, playerInfo)
  local theChar = charLib[tonumber(playerInfo.viewing)]
  return makeStatusString(withBrackets, theChar)
end

function cbreChangeDice(player, state, id)
  local pre = getPre(id)
  local click = getClick(state)
  updateUI(pre..'inputDice', "text", math.min(math.max(gatn(pre..'inputDice', "text") + (iif(string.sub(id, 8, 8) == "l",-1,1)  * iif (click.left, 1, 5)),1),30))
end

function cbreDiceNumber(player, state, id)
  updateUI(id, "text", math.min(math.abs(getNumber(state)),30))
end

function cbGetSkillRoll(theSkill, playerInfo)
  local theChar = charLib[tonumber(playerInfo.viewing)]
  local skill = copy(theSkill)
  if skill.targetBase != "num" and skill.targetBase != nil then
    skill.targetNumber = getRollFromStat(getStatValue(theChar.stats, skill.targetBase))
    skill.targetNumber = skill.targetNumber + skill.level
  else
    skill.targetNumber = rollToNum(skill.roll)
  end
  skill.targetNumber = iif(skill.familiarity, 8, skill.targetNumber)
  skill.targetNumber = iif(skill.proficiency, 10, skill.targetNumber)
  return skill.targetNumber
end

function cbreGetRollData(player,state,id,toSave)
  local pre = getPre(id)
  local playerInfo = cbgetPlayerFromPre(pre)
  local theChar = charLib[tonumber(playerInfo.viewing)]
  local saveName = gat(pre.."cbreSaveName", "text")
  if (saveName == nil) or (saveName=="") then saveName = "Quick Roll" end

  local whichType = ""
  for _,toggle in pairs({"damageTog","targetTog","tohitTog"}) do
    if gatb(pre..toggle,"isOn") then
      whichType = string.sub(toggle,1,#toggle-3)
      break
    end
  end

  local savepack = {
    name              = saveName,
    halfDice          = gatb(pre.."cbreHalfSwitch", "isOn"),
    killingAttack     = gatb(pre.."cbreKillSwitch", "isOn"),
    gameEdition       = 6,
    dice              = gatn(pre.."inputDice", "text"),
    stunMultiplierMod = gatn(pre.."cbreStunMod", "text"),
    diceMod           = gatn(pre.."cbreDiceMod", "text"),
    stdEffect         = gatb(pre.."standardTog", "isOn"),
    tempMod           = 0,
  }

  if whichType == "target" then
    savepack.halfDice = false
    savepack.dice = 3
    savepack.dicemod = 0
    savepack.targetCheck = true
    savepack.toHit = false
    savepack.stdEffect = false
    if not(toSave) then
      savepack.name = "Quick Target Roll"
    end
    savepack.targetBase = "num"
    savepack.targetNumber = gatn(pre.."cbreTargetNumber", "text")
    savepack.targetMod = gatn(pre.."cbreTargetRowMod","text")
    for name,detail in pairs(statOrder) do
      if detail.base and gatb(pre.."target" ..name .. "Tog", "isOn") then
        --print("name ", name)
        local stats = theChar.stats
        savepack.targetNumber = iif(toSave, -1, getRollFromStat(getStatValue(stats, name)))
        savepack.targetBase = name
        break
      end
    end
  elseif whichType == "tohit" then
    savepack.halfDice = false
    savepack.dice = 3
    savepack.dicemod = 0
    savepack.toHit = true
    savepack.targetCheck = false
    savepack.stdEffect = false
    if not(toSave) then
      savepack.name = "Quick To Hit Roll"
      local stats = theChar.stats
      savepack.OCV = iif (gatb(pre.."cbreOCVSwitch","isOn"), getStatValue(stats, "ocv"), getStatValue(stats, "omcv"))
    end
    savepack.ocvMod = gatn(pre.."cbreCVMod","text")
    savepack.useOCV = gatb(pre.."cbreOCVSwitch","isOn")
    savepack.DCV = gatn(pre .. "cbreDCVMod", "text")
    savepack.useDCV = gatb(pre.."cbreOCVSwitch","isOn")
    if gatb(pre.."cbreRangedSwitch","isOn") then
      savepack.useRanged = true
      savepack.rangeMod = gatn(pre.."cbreRangedMod", "text")
    end
  end

  local tool = savepack.dice .. getHalf(savepack.halfDice) .. "d6" .. addPlusNoZero(savepack.diceMod) .. " "
  if savepack.killingAttack then
    if savepack.gameEdition == 6 then
      tool = tool .. "K " .. "½d6" .. addPlusNoZero(savepack.stunMultiplierMod) .. " "
    else
      tool = tool .. "K " .. "1d6" .. addPlusNoZero(getNumber(savepack.stunMultiplierMod) - 1) .. " "
    end
  elseif savepack.targetCheck then
    local numDesc = iif (savepack.targetBase != "num", string.upper(savepack.targetBase) .. " roll", savepack.targetNumber)
    tool = tool .. "Target: " .. numDesc .. addPlusNoZero(getNumber(savepack.targetMod)) .. " "
  elseif savepack.toHit then
    tool = tool .. "To Hit "
  end

  local toolInput = gat(pre.."cbreToolInput", "text")

  if toolInput == "" or toolInput == nil then
    savepack.tool = string.sub(tool, 1, -2)
  else
    savepack.tool = toolInput
  end
  return copy(savepack)
end

function cbreRollNow(player,state,id) --print("SAVE - Player: ",player.color,", State: ", state,", ID: ",id)
  local pre = getPre(id)
  local playerInfo = cbgetPlayerFromPre(pre)
  local savePack = cbreGetRollData(player,state,id,false)
  cbdoRoll(player,state,id,savePack)
end

function cbreSaveNow(player,state,id) --print("SAVE - Player: ",player.color,", State: ", state,", ID: ",id)
  local pre = getPre(id)
  local playerInfo = cbgetPlayerFromPre(pre)
  local theChar = charLib[tonumber(playerInfo.viewing)]
  local savePack = cbreGetRollData(player,state,id,true)
  if getNumber(state) > 0 then
    theChar.rollList[getNumber(state)] = savePack
  else
    previousNumberOfRolls = #theChar.rollList
    table.insert(theChar.rollList, savePack)
    currentNumberOfRolls = #theChar.rollList
  end
  cbreCancelNow(player,state,id) -- tidy interface
end

function cbreMoveRoll(player,state,id) --print("MOVEDN - Player: ",player.color,", State: ", state,", ID: ",id)
  local pre = getPre(id)
  local playerInfo = cbgetPlayerFromPre(pre)
  local theChar = charLib[tonumber(playerInfo.viewing)]
  local direction = iif(string.sub(id,8,9) == "Dn", 1, -1) -- premoveDn
  local originalState = getNumber(state)
  local newState = state + direction
  local tempRoll = copy(theChar.rollList[newState])
  theChar.rollList[newState] = theChar.rollList[originalState]
  theChar.rollList[originalState] = tempRoll
  cbreEditNow(player,originalState,pre .. "edit" .. newState)
end

function cbrePossibleSave(player,state,id)
  local pre = getPre(id)
  updateUI(pre.."cbreSaveName", "active",true)
  updateUI(pre.."cbreToolInput", "active",true)

  updateUI(pre.."createDoing", "preferredHeight",34)
  updateUI(pre.."saveNameRow", "preferredHeight",34)
  updateUI(pre.."toolRow", "preferredHeight",34)
  updateUI(pre.."deleteSaveCancelRow", "preferredHeight",34)
  updateUI(pre.."moreRow", "preferredHeight",1)
  updateUI(pre.."deleteSaveCancelRow", "active",false)
  updateUI(pre.."deleteSaveCancelRow", "active",true)
end

function cbreEditNow(player,state,id)
  local pre = getPre(id)
  local playerInfo = cbgetPlayerFromPre(pre)
  local theChar = charLib[tonumber(playerInfo.viewing)]
  cbreCancelNow(player,state,id)
  local editRoll = getNumber(string.sub(id, 8))
  local theRoll = theChar.rollList[editRoll]
  updatesUI(pre..'rollSave'..editRoll,{
    text      = "Editing: " .. theRoll.name,
    textColor = "#CCCCCC",
  })
  updateUI(pre.."newRollTitle", "text","Editing: " .. theRoll.name)
  updateUI(pre.."cbreSaveName", "active",true)
  updateUI(pre.."cbreToolInput", "active",true)
  updateUI(pre.."createDoing", "preferredHeight",34)
  updateUI(pre.."saveNameRow", "preferredHeight",34)
  updateUI(pre.."toolRow", "preferredHeight",34)
  updateUI(pre.."deleteSaveCancelRow", "preferredHeight",34)
  updateUI(pre.."moreRow", "preferredHeight",1)

  updateUI(pre.."inputDice", "text",theRoll.dice)
  updateUI(pre.."cbreHalfSwitch", "isOn",theRoll.halfDice)
  updateUI(pre.."cbreKillSwitch", "isOn", theRoll.killingAttack)
  updateUI(pre.."cbreStunMod", "text", theRoll.stunMultiplierMod)
  updateUI(pre.."cbreDiceMod", "text", theRoll.diceMod)
  updateUI(pre.."cbreTargetNumber", "text", theRoll.targetNumber)
  updateUI(pre.."cbreTargetRowMod", "text", theRoll.targetMod)
  updateUI(pre.."cbreRangedMod", "text", iif(theRoll.rangeMod,theRoll.rangeMod,0))
  updateUI(pre.."standardTog", "isOn",theRoll.stdEffect)

  updateUI(pre.."cbreOCVSwitch", "isOn",theRoll.useOCV)
  updateUI(pre.."cbreOMCVSwitch", "isOn", not(theRoll.useOCV))
  updateUI(pre.."cbreCVMod", "text", iif(theRoll.ocvMod,theRoll.ocvMod,0))
  updateUI(pre.."cbreDCVMod", "text", iif(theRoll.DCV,theRoll.DCV,0))

  updateUI(pre.."cbreToolInput", "text",theRoll.tool)
  updateUI(pre.."cbreSaveName", "text",theRoll.name)
  updateUI(pre.."cbreCancelNow", "onClick", "cbreCancelNow("..editRoll..")")
  updateUI(pre.."cbreSaveNow","onClick", "cbreSaveNow("..editRoll..")")

  if theRoll.targetCheck then
    cbtargetChoice(player,true ,pre.."target" ..theRoll.targetBase .. "Tog")
  end
  if playerInfo.sections.RollMaker.hidden then
    cbhideSection(player,-1,pre,false,"RollMaker")
  end
  cbshowRollBlock(playerInfo.desc,not(theRoll.targetCheck or theRoll.toHit),pre.."damageTog")
  cbshowRollBlock(playerInfo.desc,theRoll.targetCheck,pre.."targetTog")
  cbshowRollBlock(playerInfo.desc,theRoll.toHit,pre.."tohitTog" )

  if editRoll > 1 then -- Not the first roll
    updatesUI(pre.."cbreDeleteNow",{
      active = true,
      onClick = "cbreDeleteNow("..editRoll..")",
    })
    if editRoll > 2 then -- second roll cannot go up
      updatesUI(pre.."moveUp",{
        active = true,
        onClick = "cbreMoveRoll("..editRoll..")",
      })
    end
    if editRoll < #theChar.rollList then -- last roll cannot go down
      updatesUI(pre.."moveDn",{
        active = true,
        onClick = "cbreMoveRoll("..editRoll..")",
      })
    end
  end
end

function cbreCancelNow(player,state,id)
  local pre = getPre(id)
  local playerInfo = cbgetPlayerFromPre(pre)
    --print("CANCEL - Player: ",player.color,", State: ", state,", ID: ",id)
    updateUI(pre.."createDoing", "preferredHeight",1)
    updateUI(pre.."saveNameRow", "preferredHeight",1)
    updateUI(pre.."toolRow", "preferredHeight",1)
    updateUI(pre.."deleteSaveCancelRow", "preferredHeight",1)
    updateUI(pre.."moreRow", "preferredHeight",34)
    updateUI(pre.."cbreSaveName", "active",false)
    updateUI(pre.."cbreToolInput", "active",false)

    updateUI(pre.."inputDice", "text","3")
    updateUI(pre.."cbreSaveName", "text", "")
    updateUI(pre.."cbreHalfSwitch", "isOn",false)
    updateUI(pre.."cbreKillSwitch", "isOn", false)
    updateUI(pre.."cbreStunMod", "text", 0)
    updateUI(pre.."cbreDiceMod", "text", 0)
    updateUI(pre.."cbreTargetNumber", "text", 0)
    updateUI(pre.."standardTog", "isOn", false)
    updateUI(pre.."cbreToolInput", "text","")
    updateUI(pre.."newRollTitle", "text","Create a new Roll ...")
    updateUI(pre.."cbreCancelNow", "onClick", "cbreCancelNow")
    updateUI(pre.."cbreSaveNow", "onClick", "cbreSaveNow")
    updateUI(pre.."cbreDeleteNow", "active", false)
    updateUI(pre.."cbreDeleteNow", "onClick", "cbreDeleteNow")
    updateUI(pre.."cbreOCVSwitch","isOn",true)
    updateUI(pre.."cbreOMCVSwitch","isOn",false)
    updateUI(pre.."cbreRangedSwitch","isOn",true)
    updateUI(pre.."cbreRangedMod", "text", 0)
    updateUI(pre.."cbreDCVMod", "text", 0)
    updateUI(pre.."cbreCVMod", "text", 0)
    updateUI(pre.."cbreTargetRowMod", "text", 0)
    updatesUI(pre.."moveUp",{
        active = false,
        onClick = "",
    })
    updatesUI(pre.."moveDn",{
        active = false,
        onClick = "",
    })
    cbreDrawRolls(playerInfo)
    -- rebuild target toggles
    cbtargetChoice(player,"True",pre.."targetnumTog")
    for name,detail in pairs(statOrder) do
      if detail.base then
        cbtargetChoice(player, "False", pre.."target" .. name .. "Tog")
      end
    end
    -- the two following trigger a refresh
    updateUI(pre.."deleteSaveCancelRow", "active",false)
    updateUI(pre.."deleteSaveCancelRow", "active",true)
end

function cbreDeleteNow(player,state,id) --print("Player: ",player.color,"State: ", state,"ID: ",id)
  local pre = getPre(id)
  local playerInfo = cbgetPlayerFromPre(pre)
  local theChar = charLib[tonumber(playerInfo.viewing)]
  if getNumber(state) > 1 then
      table.remove(theChar.rollList, getNumber(state))
  end
  previousNumberOfRolls = math.abs(currentNumberOfRolls)
  currentNumberOfRolls = #theChar.rollList
  cbreCancelNow(player,state,id)
end

function cbrenotifyRM(pre, hidden)
  if not(hidden) then
    local playerInfo = cbgetPlayerFromPre(pre)
    if not(playerInfo.sections["RollMaker"].hidden) then
      cbshowRollBlock(playerInfo.desc,gatb(pre.."damageTog", "isOn"),pre.."damageTog")
      cbshowRollBlock(playerInfo.desc,gatb(pre.."targetTog", "isOn"),pre.."targetTog")
      cbshowRollBlock(playerInfo.desc,gatb(pre.."tohitTog",  "isOn"),pre.."tohitTog" )
    end
  end
end

function cbtargetChoice(player,state,id)
  --printArgs(player, state, id, "cbtargetChoice")
  local pre = getPre(id)
  local theState = getBool(state)
  local whichTab = string.lower(string.sub(id, 10, 12))
  updateUI(id,"isOn",theState)
  if theState then
    if whichTab == "num" then
      updateUI(pre.."cbreTargetNumber","active",true)
      updateUI(pre.."cbreTargetStat","active",false)
      updateUI(pre.."cbreTargetText","text","Target Number")
    else
      updateUI(pre.."cbreTargetNumber","active",false)
      updatesUI(pre.."cbreTargetStat",{
        active = true,
        text   = string.upper(whichTab),
      })
      updateUI(pre.."cbreTargetText","text","Target base")
    end
  end
end

function cbshowRollBlock(player,state,id) --printArgs(player, state, id, "cbshowRollBlock")
  local pre = getPre(id)
  local whichTab = string.sub(id, 4, 6)
  local theState = getBool(state)
  updateUI(id,"isOn",getBool(state))
  if whichTab == "dam" then
    for key,value in pairs({"cbreHalfSwitch","diceMakeRow","killingRow"}) do
      updateUI(pre..value, "active", theState)
    end
  elseif whichTab =="tar" then
    for key,value in pairs({"gridBase","targetBaseRow","targetRow"}) do
      updateUI(pre..value, "active", theState)
    end
  elseif whichTab =="toh" then
    for key,value in pairs({"ocvChoice","cbreRangedSwitch","toHitRow","toHitTwoRow"}) do
      updateUI(pre..value, "active", theState)
    end
  end
end

function linkKill(player,state,id)
  local pre = getPre(id)
  local playerInfo = cbgetPlayerFromPre(pre)
  local theChar = charLib[tonumber(playerInfo.viewing)]
  theChar.link=""
  charLibGUID[tonumber(playerInfo.viewing)] = nil
  updateUI(pre..'linkName',"text","")
end

function cblinkToFigure(player,state,id)
  local click = getClick(state)
  local pre = getPre(id)
  local playerInfo = cbgetPlayerFromPre(pre)
  local theChar = charLib[tonumber(playerInfo.viewing)]
  --print("Player: ",player,"State: ", state,"ID: ",id)
  local objTbl = (player.getSelectedObjects())
  if #objTbl != 1 then
    return nil
  else
    --print(objTbl[1].getName())
    updateUI(pre..'linkName',"text",objTbl[1].getName())
    theChar.link = objTbl[1].getGUID()
    charLibGUID[tonumber(playerInfo.viewing)] = objTbl[1].getGUID()
    --getObjectFromGUID
  end
end

function cbcenterOnFigure(player, state, id)
  local pre = getPre(id)
  local playerInfo = cbgetPlayerFromPre(pre)
  local theChar = charLib[tonumber(playerInfo.viewing)]
  local look_pitch = 35
  local look_distance = 15

  if theChar.link then
    local obj = getObjectFromGUID(theChar.link)
  	--local pos = obj.getPosition()
  	if obj then
  		player.lookAt({
  			position = obj.getPosition(),
  			pitch    = look_pitch,
  			yaw      = player.getPointerRotation()+180,
  			distance = look_distance,
  		})
  	end
  end
end

function checkDistance(player,state,id)
  --print("Player: ",player,"State: ", state,"ID: ",id)
  local pre = getPre(id)
  local playerInfo = cbgetPlayerFromPre(pre)
  local theChar = charLib[tonumber(playerInfo.viewing)]
  local objTbl = (player.getSelectedObjects())
  local obj1
  local obj2
  if (#objTbl < 1) or (#objTbl > 2) then
    return nil
  else
    if (#objTbl == 1) and (theChar.link != "") then
      obj1 = getObjectFromGUID(theChar.link)
      obj2 = objTbl[1]
    elseif (#objTbl == 2) then
      obj1 = objTbl[1]
      obj2 = objTbl[2]
    else
      return nil
    end
    local mdiff =  obj1.getPosition() - obj2.getPosition()
    mDistance = math.sqrt(mdiff.x^2 + mdiff.y^2 + mdiff.z^2)
    --print ("mdiff.x: ",mdiff.x, ", mdiff.y: ",mdiff.y,", mdiff.z: ", mdiff.z )
    mDistance = math.floor(mDistance * (10/1)) / 10
    --mDistance = mDistance
    --print (objTbl[1].getName(), " to ", objTbl[2].getName(), ", = ",  mDistance,"m." )
    return {distance=mDistance,x=mdiff.x,y=mdiff.y,z=mdiff.z, obj1=obj1.getName(),obj2=obj2.getName()}
  end
end

function cbdistCheck(player,state,id)
  local click = getClick(state)
  local pre = getPre(id)
  local playerInfo = cbgetPlayerFromPre(pre)
  local theChar = charLib[tonumber(playerInfo.viewing)]
  local distanceInfo = checkDistance(player,state,id)
  if distanceInfo == nil then
    printToColor ("Too many or too few items selected to calculate distance",playerInfo.desc,playerInfo.colour )
    return
  end
  local xandz = math.floor(math.sqrt(distanceInfo.x^2 + distanceInfo.z^2)+0.5)

  if click.right then
    updateUI(pre..'rangeMod',"isOn",true)
  end
  updateUI(pre..'statWidthMod',"text",math.abs(xandz))
  updateUI(pre..'statHeightMod',"text",math.abs(math.floor(distanceInfo.y+0.5)))
  --{distance=mDistance,x=mdiff.x,y=mdiff.y,z=mdiff.z}
  --pl(distanceInfo)
  if distanceInfo.obj1 == "" then distanceInfo.obj1 = "Unknown" end
  if distanceInfo.obj2 == "" then distanceInfo.obj2 = "Unknown" end
  printToColor ("The distance from " .. distanceInfo.obj1 .. " to " .. distanceInfo.obj2 .. " is " .. math.floor(distanceInfo.distance+0.5) .. iif(click.right, " (range mod activated)","") ,playerInfo.desc ,playerInfo.colour )
  Wait.frames(function() cbupdatePythag(pre) end, 2)
end

function cbtestInput(player,state,id)
  local pre = getPre(id)
  local playerInfo = cbgetPlayerFromPre(pre)
  local whichStatus = tonumber(string.sub(id,13,13))
  if getClick(state).right then
    --print ("Got to the right click on the custom status")
    updateUI(id,"active",false)
    updateUI(pre.."statusMod" ..whichStatus.. "input","active",true)
  end
end

function cbchangeCustomStatus(player,state,id)
  --printArgs(player, state, id, "cbchangeCustomStatus")
  local pre = getPre(id)
  local playerInfo = cbgetPlayerFromPre(pre)
  local theChar = charLib[tonumber(playerInfo.viewing)]
  local whichStatus = tonumber(string.sub(id,13,13))
  local toggleID = pre.."statusMod"..whichStatus
  theChar.status[whichStatus].shortName  = state
  theChar.status[whichStatus].name       = state
  theChar.status[whichStatus].startPost  = "is now " .. state
  theChar.status[whichStatus].finishPost = "is no longer " .. state
  theChar.status[whichStatus].tool       = "Custom Status: (".. state ..") Defined by the player"
  updateUI(id,"active",false)
  updatesUI(toggleID,{
    text    = theChar.status[whichStatus].name,
    active  = true,
    tooltip = theChar.status[whichStatus].tool,
  })
  cbupdateStatusMod(player,gatb(toggleID,"isOn"), toggleID)
end

----------

-- Combat controls

----------

function ccIsInCombat(guid)
  for _,theChar in pairs(ccplayers) do
    if theChar.guid == guid then
      return true
    end
  end
  return false
end

function calcInit(dex,int,pre,lr,rand)
	--print ("Got LR ", lr)
	return ((tonumber(dex)+(tonumber(lr))) * 10000000) +
          (tonumber(int) * 100000) +
          (tonumber(pre) * 1000) +
           tonumber(rand) -- random number 0-999
end

function calcLR(player)
	local currentLR = 0
	if player.lightningReflex then
    for i = 1, #player.lightningReflex do
      if player.lightningReflex[i].isActive then
        currentLR = currentLR + tonumber(player.lightningReflex[i].levels)
      end
    end
  end
	return currentLR
end

function addToCombat(line)
  for _,nc in pairs(ccplayers) do
    if nc.guid == line then -- already in combat (to deal with add all)
      return false
    end
  end
  local theChar = charLib[tonumber(line)]
	theChar.speed = tonumber(getStatValue(theChar.stats, "spd"))
	theChar.next = 12
	theChar.hasNotPhased=true
	theChar.isAborted=false
	theChar.isSpeedChange=false
	theChar.abort=-1
	theChar.recoverAbort=-1
	theChar.isHolding=false
	theChar.holdOverride=false
	theChar.holdFull=false
	theChar.startedHolding=-1
	theChar.loseHold=-1
	theChar.color=iif(theChar.currentColor=="black","#888888",theChar.currentColor)
	theChar.guid=line
	theChar.init=calcInit(getStatValue(theChar.stats, "dex"),getStatValue(theChar.stats, "int"),getStatValue(theChar.stats, "pre"),calcLR(theChar), theChar.random)

  table.insert(ccplayers,theChar)
  table.sort(ccplayers, function(a,b) return tonumber(a.init) > tonumber(b.init) end)
	return true
end

function ccreDrawByMode(mode)
  if cccombatMode then
		reDrawUI(mode)
	else
		reDrawPreCombatUI()
	end
end

function getTimeLine(thePlayer)
	-- return the timeline .. but check thePlayer.next for the next time the player phases and overwrite all with dashes till then
	-- also need to check nextPhasesin12(nextPlayer)
  --local returnString = table.concat(timeLine[thePlayer.speed], "", segment+1, segment+13)
	-- need to test against Player.next
	-- ccsegmentNumPlain
	--"―","―","―","―","―","―","⑦","―","―","―","―","―","<b>ⓡ</b>"
	--"①②③④⑤⑥⑦⑧⑨⑩⑪⑫<b>ⓡ</b>"
	--string.find("①②③④⑤⑥⑦⑧⑨⑩⑪⑫<b>ⓡ</b>", string.sub(returnString, i, i+1))
  --for i=segment+1,math.min(player.next,segment+13) do
  --local test = string.sub(returnString, i, i+1)
  --if (test == "<") or (test == "b") or (test == ">")  or (test == "ⓡ") or (test == "/") then
  			--do nothing
  --else

  --end
  --end
  --return returnString
end

--

--  Clock / Turn / Segment functions

--

function incrementSegment (segment)
  return iif((segment + 1) % 12 == 0, 12, (segment + 1) % 12)
end

function clockForward(player,state,id)
  if getBool(state) and (#ccplayers > 0) then
    cccombatMode = true
    for i=1,maxLibSize do
			if gatb("combatRowPlayer"..i,"active") then
				updateUI("combatRowPlayer"..i,"active",false)
			end
	  end
    nextSegment()
    return
  end

  if (getPhasing() == 0) and cccombatMode then
    segment = segment + 1
  	if segment > 13 then
  		segment = 1
  		turn = turn + 1
  	end
	  nextSegment()
  end
end

function nextSegment()
	-- Check held and Aborted to see if any happen.
	-- then redraw everything
	local segOutput = segment
	if segment == 13 then
		segOutput = "Post Segment 12"
	end
	--local issue={Turn=turn,Segment=segment}
	--sendExternalMessage(issue)
	broadcastToAll("Turn: " .. turn .. ", Segment: " .. segOutput, Color.white)

  for i,player in pairs(ccplayers) do
		if player.isAborted == true and player.recoverAbort == segment then -- should not need the first test .. get aborted tests that
			announce(player.name  .. ", recovers from aborted phase " .. player.abort,player)
			notify(player.guid,{phasing=false, held=false, aborted=false})
			player.isAborted = false
			player.abort = -1
      player.recoverAbort = -1
		end

		if player.isHolding and player.loseHold == segment then
			announce(player.name  .. ", lost held phase from " .. player.startedHolding,player)
			notify(player.guid,{phasing=false, held=false, aborted=false})
			player.isHolding = false
			player.holdFull = false
      player.startedHolding=-1
      player.loseHold=-1
		end

  	if (player.next > 12) and (segment == 13) then -- adjust long term NEXT
  		player.next = player.next - 12
  	end

    player.hasNotPhased = true

  	if (player.next == segment) and (player.isSpeedChange) then
  		player.isSpeedChange = false
  	end
    -- Should still consider a speed change countdown .. will work better than this I think
  	-- also calculation is now wrong need to recheck it properly is working
  	if not((player.isAborted or player.isSpeedChange)) then
  		player.next = speedNextChart[player.speed][segment]
  	end
  end
	reDrawUI(CONST.showMsg)
end

--

-- Combat Utility Functions

--

function announce(content, player)
  if string.lower(player.currentColor) ~= "black" then
    broadcastToAll(content , Color.fromString(player.currentColor))
  else
    print(content)
  end
end

function ccgetIndex(id)
  local _, _, index = string.find(id, "(%d+)")
  return tonumber(index)
end

function notify (guid, notification)
  -- NEED TO INSERT NOTIFICATION HERE
  --local newObject = getObjectFromGUID(guid)
  --newObject.call("notify", notification)
  --return guid
end


--

-- Hold Phase Functions

--

-- use half of a held full phase.
function useHalf(player,state,id)
  local theChar = ccplayers[ccgetIndex(id)]
	theChar.holdFull = false
	announce(theChar.name  .. ", used half a held phase from segment " .. theChar.startedHolding, theChar)
	reDrawUI(CONST.noShowMsg)
end

function holdRelease(player,state,id) --print("Player: ",player,"State: ", state,"ID: ",id)
  local theChar = ccplayers[ccgetIndex(id)]
  notify(theChar.guid,{phasing=false, held=false, aborted=false})
	announce(theChar.name  .. ", used held phase from segment " .. theChar.startedHolding, theChar)
  theChar.holdOverride = true
  theChar.isHolding = false
  theChar.holdFull = true
  theChar.startedHolding = -1
  theChar.loseHold = -1
	theChar.hasNotPhased = false
  reDrawUI(CONST.showMsg)
end

function holdPhase(player,state,id)
  local theChar = ccplayers[ccgetIndex(id)]
	notify(theChar.guid,{phasing=false, held=true, aborted=false})
  theChar.isHolding = true
  theChar.holdFull = iif(state == "-2", false, true)
  theChar.startedHolding = segment
  theChar.loseHold = iif((theChar.next) % 12 == 0,12, theChar.next % 12)
  theChar.holdOverride = false
	theChar.hasNotPhased = false
	announce(theChar.name  .. ", held phase " .. segment,theChar)
  reDrawUI(CONST.showMsg)
end

--

-- Phasing Functions

--

function getPhasing()
	local count = 0
	for i,player in pairs(ccplayers) do
		--if ((speedWhenChart[player.speed][segment] == 1) or player.holdOverride) and (player.isAborted == false) and (player.hasNotPhased) and (not(player.isHolding)) then
		if (speedWhenChart[player.speed][segment] == 1) and (player.isAborted == false) and (player.hasNotPhased) and (not(player.isSpeedChange)) then
		--if ((speedWhenChart[player.speed][segment] == 1)) and (player.isAborted == false) and (player.hasNotPhased) then
			count = count + 1
			--print("player.name: ",player.name,",player.isAborted: ",player.isAborted,",player.hasNotPhased: ",player.hasNotPhased, ", player.isHolding:", player.isHolding, ", player.holdOverride:", player.holdOverride )
		end
	end
	return count
end

function getPhasingTable()
	local phasingTable = {}
	for _,player in ipairs(ccplayers) do
		if (speedWhenChart[player.speed][segment] == 1) and (player.isAborted == false) and (player.hasNotPhased) and (not(player.isHolding)) and (not(player.isSpeedChange)) then
			table.insert(phasingTable, player)
		end
	end
	return phasingTable
end

function hasPhasedNow(player,state,id)
  local theChar = ccplayers[ccgetIndex(id)]
	notify(theChar.guid, {phasing=false, held=false, aborted=false})
  theChar.hasNotPhased = false
  theChar.holdOverride = false
  reDrawUI(CONST.showMsg)
end

--

-- Next Phase Functions

--

function nextPhasesin12(player)
  local listOfNext = {}
  local tempNext = player.next
  repeat
    table.insert(listOfNext, tempNext)
    tempNext = speedNextChart[player.speed][tempNext]
  until( tempNext > (segment + 12) )
  for i,seg in pairs(listOfNext) do
    listOfNext[i] = iif((seg) % 12 == 0,12, seg % 12)
  end
  return table.concat(listOfNext, ", ")
end

--

-- Abort Phase Functions

--

function abortPhase(player,state,id)
	if string.sub(id,1,4) == "comb" then return end -- from combat section
	if tonumber(state) == -2 then
		removePlayer(player,state,id)
		if #ccplayers < 1 then
			endCombat(player,state,id)
		else
			reDrawUI(CONST.showMsg)
		end
	else
    local theChar = ccplayers[ccgetIndex(id)]
		notify(theChar.guid,{phasing=false, held=false, aborted=true})
		theChar.isAborted = true
		local tempNext = 0
    if cccheckPhasing(theChar) then
      theChar.abort = segment
      tempNext = theChar.next
    else
      theChar.abort = iif((theChar.next) % 12 == 0,12, theChar.next % 12)
      tempNext = speedNextChart[theChar.speed][theChar.next]
    end
    theChar.recoverAbort = incrementSegment(theChar.abort)
		theChar.next = tempNext
		announce (theChar.name  .. ", aborted phase " .. segment, theChar)
		reDrawUI(CONST.showMsg)
	end
end

--

-- Amend Character in combat Functions

--


function ccamendColour(guid)
  if #ccplayers == 0 then
    return false
  else
    local i = getPlayerNumberFromGuid(guid)
    local char = ccplayers[i]
    local isPhasing =  cccheckPhasing(char)
    local playerColor = char.currentColor
    local newColor = shadeFail(isPhasing,players[playerColor].color,"33")
    updateUI("nextRowName"..i,"color", newColor)
    updateUI("tvnextRowName"..i,"color", newColor)
    return true
  end
end

function ccamendStatus(guid)
  if #ccplayers == 0 then
    return false
  else
    i = getPlayerNumberFromGuid(guid)
    content = ccgetNameText(ccplayers[i])
    updateUI("nextRowName"..i,"text", content)
    updateUI("tvnextRowName"..i,"text", content)
    return true
  end
end

function ccamendReflex(guid)
  if #ccplayers == 0 then
    return false
  else
    player = ccplayers[getPlayerNumberFromGuid(guid)]
    player.init = calcInit(getStatValue(player.stats, "dex"),getStatValue(player.stats, "int"),getStatValue(player.stats, "pre"),calcLR(player), player.random)
    table.sort(ccplayers, function(a,b) return tonumber(a.init) > tonumber(b.init) end)
    ccreDrawByMode(CONST.noShowMsg)
    return true
  end
end

function ccamendHealth(guid)
  if #ccplayers == 0 then
    return false
  else
    local i = getPlayerNumberFromGuid(guid)
    local theChar = ccplayers[i]
    if theChar then
      ccupdateBars(i, theChar)
    end
    return true
  end
end

function ccamendStats(inboundParams)
  -- should get a guid, stat and new value
  print("guid: ",inboundParams.guid)
  print("stat: ",inboundParams.stat)
  print("value: ",inboundParams.value)
  -- find player and update
  local updateSuccess = false

  for i,player in pairs(ccplayers) do
    if player.guid == inboundParams.guid then
      print ("Player found: ", player.name)
      updateSuccess = true
      player[inboundParams.stat].value = inboundParams.value
      player.init = calcInit(player.dex.value,player.int.value,player.pre.value,calcLR(player), player.random)
      --print(logString(player))
      -- recalc init value
      if (inboundParams.stat == "dex") or (inboundParams.stat == "int") or (inboundParams.stat == "pre") then
        table.sort(ccplayers, function(a,b) return tonumber(a.init) > tonumber(b.init) end)
      end
      if inboundParams.stat == "spd" then
        player.isSpeedChange = true -- IMPORTANT NEEDS TO BE RESET .. WILL NEVER END OTHERWISE
        -- also important .. phasing should not work when next phase is after current segment.
        -- might have to check that
        -- need to add a speedChangeRecover and set it to the next segment when it will recover .. then check in the next segment function.
        -- also need to do a "getSpeedChange()" .. just like abort
        -- seriously consider setting countdowns on remaining aborts and speed changes .. lot of rework but cleaner than current
        local oldSpeed = copy(player.speed)
        player.speed = getNumber(inboundParams.value) -- newSpeed
        local oldNext = speedNextChart[oldSpeed][player.next]
        local newNext = speedNextChart[player.speed][player.next]
        -- if newNext ==
        player.next = speedNextChart[player.speed][math.max(oldNext,newNext)+iif(player.speed == 1,0,-1)]
        --player.next = speedNextChart[player.speed][segment]
        print ("Speed: ", player.speed)
        print ("next: ", player.next)
      end
      break
    end
  end

  if not(updateSuccess) then
    for i,player in pairs(ccnonCombat) do
      if player.guid == inboundParams.guid then
        print ("Player found: ", player.name)
        updateSuccess = true
        player[inboundParams.stat].value = inboundParams.value
        if inboundParams.stat == "dex" then
          --table.sort(ccnonCombat, function(a,b) return tonumber(a.dex.value) > tonumber(b.dex.value) end)
          table.sort(ccnonCombat, function(a,b) return tonumber(a.init) > tonumber(b.init) end)
        end
        break
      end
    end
  end
  if updateSuccess then
    ccreDrawByMode(CONST.noShowMsg)
    return true
  end
  return false
end

--

-- Render and Draw UI

--

function ccgetStatusString(thePlayer, withBrackets)
  return " " .. makeStatusString(withBrackets, charLib[tonumber(thePlayer.guid)])
end

function ccupdateBars(i, theChar)
  for _,stat in pairs({"body","stun","end"}) do
    local statValue = getStatValue(theChar.stats,stat)
    local statOrigin = getStatOrigin(theChar.stats,stat)
    local percentage = math.max(math.min(math.floor(((statValue / statOrigin) * 100)+0.5),100),0)
    updateUI(stat.."Bar"..i,"percentage", percentage)
    updateUI(stat.."Bar"..i,"tooltip", firstToUpper(stat) .. " " .. statValue .. " / " .. statOrigin )
  end
end

function ccgetNameText(nextPlayer)
  return " " .. nextPlayer.name .. " (" .. getStatValue(nextPlayer.stats, "dex") .. addPlusNoZero(calcLR(nextPlayer)) .. ")".. ccgetStatusString(nextPlayer, true)
end

function ccgetToolText(nextPlayer)
  return "<color=#888888>Speed: </color>" .. nextPlayer.speed .. "\n<color=#888888>Dex: </color>" .. getStatValue(nextPlayer.stats, "dex") .. "\n<color=#888888>Phases: </color>".. nextPhasesin12(nextPlayer)
end

function cccheckPhasing(player)
  if (speedWhenChart[player.speed][segment] == 1) and (player.isAborted == false) and (player.hasNotPhased) and (not(player.isHolding)) and (not(player.isSpeedChange)) then
    return true
  end
  return false
end

function checkUpdates(checkTable)
  local returnTable = {}
  local id = checkTable.id
  for key, value in pairs(checkTable.checks) do
    if type(value) == boolean then
      if gatb(id,key) != value then
        returnTable[key] = value
      end
    elseif type(value) == number then
      if gatn(id,key) != value then
        returnTable[key] = value
      end
    else
      if gat(id,key) != value then
        returnTable[key] = value
      end
    end
  end
  return returnTable
end

function ccchangeCharacterInBrowser(player,state,id)
  scchangeGMBrowser(player,"anything",twodigitnumber(ccplayers[ccgetIndex(id)].guid))
  --scchangeCharacterInBrowser("black", twodigitnumber(ccplayers[ccgetIndex(id)].guid))
end

function reDrawUI(showMessage)
  --
  -- Section Headers
  --
	updateUI('tvtitle',"text", " Turn Viewer - " .. "Turn "..turn.." - ".. iif(segment~=13, "Segment "..segment,"Post Segment 12"))

	updatesUI("turnClock",{
		text = ccsegmentNumbers[segment],
		onClick = "clockForward",
		color = iif(segment~=13,"#FFFFFF","#00CC00"),
	})
	updatesUI("turnText", {
		text = "Turn "..turn..iif(segment~=13, ", Segment "..segment,", Post Segment 12"),
		onClick = "clockForward",
    tooltip="Click to advance a turn",
	})

  local holdCount,abortCount = 0, 0
  --local abortCount = 0
	for i,player in pairs(ccplayers) do
		if player.isHolding then holdCount = holdCount + 1 end
    if player.isAborted then abortCount = abortCount + 1 end
	end

  local phasingTable = getPhasingTable()
	updateUI("heldRowText","text"," Held: ".. holdCount .. ", Phasing: " .. #phasingTable .. ", Aborted: " .. abortCount)

  --
  -- Next Phase section
  --

	-- Announce current player.
	if (#phasingTable > 0) and showMessage then
		local phasingPlayer = phasingTable[1]
		notify(phasingPlayer.guid, {phasing=true, held=false, aborted=false})
		announce("Player Phase: " ..  phasingPlayer.name,phasingPlayer)
	end

  local count = 0
	for i,nextPlayer in pairs(ccplayers) do
    local isPhasingNow = cccheckPhasing(nextPlayer)
    local isHoldingNow = nextPlayer.isHolding
    local phaser = false
    if isPhasingNow then
      phaser = iif(phasingTable[1].guid == nextPlayer.guid,true,false)
    end
    ccupdateBars(i, nextPlayer)

    local updateTable = checkUpdates({ id = "nextRowPlayer"..i, checks = {
      active     = true,
      visibility = iif(nextPlayer.currentColor=="black", "Black|Spades", "Black|Diamonds|Spades"),
    }})

    if next(updateTable) then
      updatesUI("nextRowPlayer"..i,updateTable)
      updatesUI("tvnextRowPlayer"..i,updateTable)
    end

    local phaseTable = checkUpdates({ id = "nextRowPhase"..i, checks = {
      text       = iif(nextPlayer.isAborted,crossMark,checkMark),
      color      = iif(isPhasingNow,iif(phaser,"#CCCCCC","#222222"), iif(isHoldingNow,"#00CC00",iif(nextPlayer.isAborted,"#330000","#000000"))),
      tooltip    = iif(isPhasingNow,iif(phaser,"Use players phase","Waiting for phase"),iif(isHoldingNow,"Use players held" .. iif(nextPlayer.holdFull,"", " ½") .. " on phase " .. nextPlayer.startedHolding,iif(nextPlayer.isAborted,"Player aborted phase ".. nextPlayer.abort .. ", recovers on " .. nextPlayer.recoverAbort,""))),
    }})

    if next(phaseTable) then
      updatesUI("nextRowPhase"..i,phaseTable)
      updatesUI("tvnextRowPhase"..i,phaseTable)
    end

    if gat("nextRowPhase"..i,"onClick") != iif(isPhasingNow,iif(phaser,"hasPhasedNow(".. i ..")",iif(isHoldingNow,"holdRelease()","")),iif(isHoldingNow,"holdRelease()","")) then
      updateUI( "nextRowPhase"..i,"onClick", iif(isPhasingNow,iif(phaser,"hasPhasedNow(".. i ..")",iif(isHoldingNow,"holdRelease()","")),iif(isHoldingNow,"holdRelease()","")))
    end

    local nameTable = checkUpdates({ id = "nextRowName"..i, checks = {
      text       = ccgetNameText(nextPlayer),
      color      = shadeFail(isPhasingNow,players[nextPlayer.currentColor].color,"33"),
      tooltip    = ccgetToolText(nextPlayer),
      onClick    = "ccchangeCharacterInBrowser",
    }})

    if next(nameTable) then
    	updatesUI("nextRowName"..i,nameTable)
      updatesUI("tvnextRowName"..i,nameTable)
    end

    local abortTable = checkUpdates({ id = "nextRowAbort"..i, checks = {
      active     = iif(nextPlayer.isAborted or (isHoldingNow and not(nextPlayer.holdFull))or (segment==13),false,true),
      text       = iif(phaser or (isHoldingNow and nextPlayer.holdFull),holdMark,crossMark),
      color      = iif((isHoldingNow and nextPlayer.holdFull),"#009900" ,"#CCCCCC"),
      tooltip    = iif(phaser,"l-click to hold for 1 phase\nr-click for half phase",iif((isHoldingNow and nextPlayer.holdFull),"Click to use half of held phase","Click to abort next phase")),
      onClick    = iif(isPhasingNow,iif((phaser),"holdPhase","abortPhase"),iif(isHoldingNow and nextPlayer.holdFull,"useHalf","abortPhase")),
    }})

    if next(abortTable) then
    	updatesUI("nextRowAbort"..i,abortTable)
    end

    --ccsegmentNumbers = {"①","②","③","④","⑤","⑥","⑦","⑧","⑨","⑩","⑪","⑫","<b>ⓡ</b>"}
  	--print("ccsegmentNumbers[(nextPlayer.next % 12)] ", ccsegmentNumbers[(nextPlayer.next % 12)], (nextPlayer.next % 12))

    local nextPlayPhase = (nextPlayer.next % 12)
    if nextPlayPhase == 0 then nextPlayPhase = 12 end

    local clockTable = checkUpdates({ id = "nextRowClock"..i, checks = {
      text    = ccsegmentNumbers[nextPlayPhase],
      tooltip = "Next Phases:- " .. nextPhasesin12(nextPlayer),
    }})

    if next(clockTable) then
      updatesUI("nextRowClock"..i,clockTable)
    end

    local phasesTable = checkUpdates({ id = "tvnextRowPhases"..i, checks = {
      text       = table.concat(timeLine[nextPlayer.speed], "", segment+1, segment+13),
      color      = shadeFail(isPhasingNow,nextPlayer.color,"33"),
      tooltip    = "Next Phases:- " .. nextPhasesin12(nextPlayer),
    }})

    if next(phasesTable) then
      updatesUI("tvnextRowPhases"..i,phasesTable)
    end
  end
	for i=#ccplayers + 1,maxLibSize do
		if gatb("nextRowPlayer"..i, "active") then
  		updateUI("nextRowPlayer"..i,"active",false)
      updateUI("tvnextRowPlayer"..i,"active",false)
		else
			break
		end
  end
end

function reDrawPreCombatUI(firstTime)
  --
  -- Section Headers
  --

  if firstTime then printToAll("....20%",{r=0,g=0.2,b=0}) end
  updatesUI("turnClock",{
		onClick = "clockForward(true)",
		text=ccsegmentNumbers[12],
		tooltip="Click to advance a turn",
	})

  updatesUI("turnText",{
		onClick = "clockForward(true)",
		text="Click here to begin combat",
		tooltip="Click to begin combat",
	})

  --
  -- Combatant section
  --

	for i,player in pairs(ccplayers) do -- if move to hash table with key as guid will need to be incremental count instead of i
		updatesUI("combatRowPlayer"..i,{
			active = true,
		})
		updatesUI("combatRowAbort"..i,{
			onClick = "removePlayer",
		})
		updatesUI("combatRowName"..i,{
			color = player.color,
			text = player.name .. " (" .. getStatValue(player.stats, "dex") .. ")",
			tooltip = "Speed: " .. player.speed .. ", Dex: " .. getStatValue(player.stats, "dex") ,
		})
	end

	for i=#ccplayers + 1,maxLibSize do -- if move to hash table with key as guid will need to be incremental count instead of i
		if gatb("combatRowPlayer"..i, "active") then
			updateUI("combatRowPlayer"..i,"active",false)
		end
	end
	--
	-- Configuration Section
	--

  if firstTime then
    Wait.frames(function() printToAll ("..........40%",{r=0,g=0.4,b=0})  end, 130)
    Wait.frames(function() printToAll (".................60%",{r=0,g=0.6,b=0})  end, 260)
    Wait.frames(function() printToAll ("........................80%",{r=0,g=0.8,b=0})  end, 390)
    Wait.frames(function() printToAll ("Hero System loaded",{r=0,g=1,b=0})  end, 520)
  end
end

function unloadAllCombat(player,state,id) -- print("Player: ",player,"State: ", state,"ID: ",id)
  for i=#ccplayers,1,-1 do
	   removePlayer(player,i,"nextRowName" .. i, true) -- true is do not rebuild
  end
  reDrawUI(CONST.showMsg)
end

function endCombat(player,state,id)
	if cccombatMode then
		if #ccplayers > 0 then -- if move to hash table with key as guid will need to be checked
			unloadAllCombat(player,state,id)
		end
		turn=1
		segment=12
		cccombatMode = false
		reDrawPreCombatUI()
		updateUI('tvtitle',"text", " Turn Viewer - PreCombat")
		printToAll("Combat Ends", {r=1,g=1,b=1})
	end
end

function addPlayer(player,state,id,noRebuild)  -- NOT USED ANYMORE
  local selectedPlayer = tonumber(string.sub(id,16))
  local inCombat = false
  --print("selectedPlayer: ",selectedPlayer)
  if state == "combat" then inCombat = true end
  local whichCurrent = ccnonCombat[selectedPlayer].stats.str.current
  local dexToCheck = ccnonCombat[selectedPlayer].stats.dex[whichCurrent].value
  ccnonCombat[selectedPlayer].next = speedNextChart[ccnonCombat[selectedPlayer].speed][segment]

  announce(ccnonCombat[selectedPlayer].name  .. ", entered combat on segment " .. segment,ccnonCombat[selectedPlayer])
  local checkDone = false

  for i,player in ipairs(ccplayers) do -- should be replaced with table sort .. very slow
    local whichCurrent = player.stats.str.current
    if dexToCheck >= player.stats.dex[whichCurrent].value then
      table.insert(ccplayers,i,ccnonCombat[selectedPlayer])
      checkDone = true
      break
    end
  end
  if not(checkDone) then
    table.insert(ccplayers,ccnonCombat[selectedPlayer])
  end
  --print ("table remove ",selectedPlayer)
  table.remove(ccnonCombat,selectedPlayer)
  --pl (ccnonCombat)
  if noRebuild == nil then
    ccreDrawByMode(CONST.showMsg)
  end
end

function getPlayerNumberFromGuid(guid)
	for i,player in pairs(ccplayers) do -- if move to hash table with key as guid will need to be incremental count instead of i
		if guid == player.guid then
			return i
		end
	end
	return 0
end

function removePlayer(player,state,id, noRebuild)	--printArgs(player,state,id,"removePlayer")
  local selectedPlayer = tonumber(state)
  --local gotPlayer = ""

  local theChar = ccplayers[ccgetIndex(id)]

  --	if cccombatMode then
  --  gotPlayer = getPlayerNumberFromGuid(gat(id,"playerguid"))
  --  else
    --gotPlayer = selectedPlayer
  --end

  local dexToCheck = getStatValue(theChar.stats, "dex")
  local checkDone = false

	announce (theChar.name  .. ", left combat on segment " .. segment, theChar)
  theChar.hasNotPhased=true
  theChar.isAborted=false
  theChar.abort=-1
  theChar.recoverAbort=-1
  theChar.isHolding=false
  theChar.holdOverride=false
  theChar.holdFull=false
  theChar.startedHolding=-1
  theChar.loseHold=-1

	-- tidy notifications
	notify(theChar.guid,{phasing=false, held=false, aborted=false})
  scremoveCombatant(theChar.guid)
  --table.remove(ccplayers,gotPlayer)
  if noRebuild == nil then
    ccreDrawByMode(CONST.noShowMsg)
  end
end

-- [[

-- Global Interface Functions

-- ]]

function testFunc(player,state,id)
  --printArgs(player, state, id, "testFunc")
  --print("result from scrollbar ",string.format("%1.4f",tonumber(string.sub(state,string.find(state, ",")+1))))
  --print("height (440) / number visible (40)",gat(id,"height"))
  -- visible window = 170 .. row height = 34
end

function buildAssets() -- Load game graphics from web
  local root = 'https://raw.githubusercontent.com/Thirtybird/TTSHeroMod/main/HeroMod/CustomUIAssets/'
  local assets = { -- ** NEED ** to move all of the below on Rob's server to my own
    {name='ui_hero2', url=root..'hero-128.png'},
    {name='ui_checkon', url=root..'checkbox_on.png'},
    {name='ui_checkoff', url=root..'checkbox_off.png'},
    {name='ui_arrow_u', url=root..'arrow_u.png'},
    {name='ui_arrow_d', url=root..'arrow_d.png'},
    --{name='ui_power', url=root..'power.png'},
    --{name='ui_reload', url=root..'reload.png'},
    --{name='ui_location', url=root..'location.png'},
    --{name='ui_share', url=root..'share.png'},
    {name='ui_noplayer', url=root..'noplayer64.png'},
    {name='ui_player', url=root..'player128.png'},
    {name='ui_players', url=root..'playersicon.png'},
    {name='ui_run', url=root..'run64.png'},
    {name='ui_fly', url=root..'fly64.png'},
    {name='ui_swim', url=root..'swim64.png'},
    {name='ui_glide', url=root..'glide64.png'},
    {name='ui_swing', url=root..'swing64.png'},
    {name='ui_teleport', url=root..'teleport64.png'},
    {name='ui_tunnel', url=root..'tunnel64.png'},
    {name='ui_leap', url=root..'leap64.png'},
    {name='ui_dice', url=root..'dice64.png'},
    {name='ui_hero', url=root..'hero64.png'},
    {name='ui_line', url=root..'line64.png'},
    {name='ui_target', url=root..'target-128.png'},
    {name='ui_skull', url=root..'skull-128.png'},
  }
  UI.setCustomAssets(assets)
end

function buildUIDefaults() -- Load the stylesheet defaults for the Global UI
  return {
      {tag='Defaults',children={
          {tag='Color', attributes = {name="BLA", color = "#CCCCCC"}},
          {tag='Color', attributes = {name="BLU", color = "#1E87FF"}},
          {tag='Color', attributes = {name="RED", color = "#DA1917"}},
          {tag='Color', attributes = {name="GRE", color = "#30B22A"}},
          {tag='Color', attributes = {name="YEL", color = "#E6E42B"}},
          {tag='Color', attributes = {name="ORA", color = "#F3631C"}},
          {tag='Color', attributes = {name="TEA", color = "#20B09A"}},
          {tag='Color', attributes = {name="PUR", color = "#9F1FEF"}},
          {tag='Color', attributes = {name="PIN", color = "#F46FCD"}},
          {tag='Color', attributes = {name="BRO", color = "#703A16"}},
          {tag='Tooltip',attributes={tooltipBackgroundColor='black', tooltipPosition='Above'}},
          {tag='Row',attributes={preferredHeight=34}},
          {tag='InputField',attributes={textColor='#000000', colors='#EEEEEE|#F8F8F8|#FFFFFF|rgba(0.78,0.78,0.78,0.5)',transition='None'}},
          --{tag='Text',attributes={color='#CCCCCC'}},
          {tag='Text',attributes={class='slotNum',fontSize=14,color="#888888",alignment="MiddleCenter",tooltip="Change Character"}},
          {tag='Text',attributes={class='charname',fontSize=14,resizeTextMaxSize=14,resizeTextMinSize=11,resizeTextForBestFit=true,color='#CCCCCC',alignment='MiddleLeft'}},
          {tag='Text', attributes={class="name",resizeTextForBestFit="true",resizeTextMinSize="6",resizeTextMaxSize="17",color="#CCCCCC",fontSize="17",alignment="MiddleLeft",text=""}},
          {tag='Text', attributes={class="phase",tooltip="Left click to finish phase.",tooltipPosition="Above"}},
          {tag='Text', attributes={class="next",onClick="ccswitchshowPhases"}},
          {tag='Text',attributes={class='title:@Text', onClick="cbhideGlobal", fontSize=11, fontStyle="Bold", color="#CCCCCC"}},
          {tag='InputField',attributes={class='charlist:@InputField',fontSize=14,tooltip='Enter character name', placeholder='Enter character name',transition='None'}},
          {tag='Toggle',attributes={class="charlist:@Toggle", onValueChanged="markActive", color="#CCCCCC", isOn="false", tooltip="Click to use in combat"}},
          {tag='Row',attributes={class='sepRow',preferredHeight=24, dontUseTableRowBackground=true,image="ui_line", color="#222222"}},
          {tag='InputField',attributes={class='ii3',textOffSet="2 2 2 2",characterLimit='3',characterValidation='Integer',fontSize=16, textAlignment="MiddleCenter",tooltipPosition="Above",tooltip="",text="0"}},
          {tag='Text',attributes={class="statText", fontSize=13, resizeTextMaxSize=13,resizeTextMinSize=11,resizeTextForBestFit=true, color="#FFFFFF", alignment="MiddleLeft"}},
          {tag='Text',attributes={class='rollDesc',fontSize=15,resizeTextMaxSize=15,resizeTextMinSize=11,resizeTextForBestFit=true,color='#CCCCCC',alignment='MiddleLeft',tooltipPosition="Above",text="",tooltip=""}},
          {tag='Cell',attributes={class="cs6", columnSpan=6}},
          {tag='Button',attributes={class='sepHeader',textColor='#CCCCCC',textAlignment='MiddleLeft',fontSize=12,resizeTextForBestFit=true,resizeTextMinSize=10,resizeTextMaxSize=12,colors='#22222200|#44444400|#22222200|#22222200',text=""}},
          {tag='Image', attributes={preserveAspect="true"}},
          {tag='Image', attributes={class="arrowDn",color="#CCCCCC",image="ui_circle_arrow_dn",}},
          {tag='Image', attributes={class="hold",color="#CCCCCC",onClick="holdPhase",image="ui_circle_arrow_up",tooltip="Left click hold 1 phase, Right click hold ½ phase",}},
          {tag='Image', attributes={class="abort",color="#CCCCCC",image="ui_circle_cross",tooltip="Click to abort",onClick="abortPhase",}},
          {tag='Image', attributes={class="remove",color="#CCCCCC",image="ui_circle_minus",tooltip="Click to remove from combat",}},
          {tag='Image', attributes={class="add", color="#CCCCCC", image="ui_circle_plus", tooltip="Click to add to combat",}},
          {tag='Image',attributes={class='targetImage',image="ui_target",tooltip="Target roll",tooltipPosition="Above",color='#CCCCCC'}},
          {tag='Image',attributes={class='crosshairImage',image="Sprites/Icons/Crosshair",tooltip="To Hit roll",tooltipPosition="Above",color='#CCCCCC'}},
          {tag='Image',attributes={class='skullImage',image="ui_skull",tooltip="Killing roll",tooltipPosition="Above",color='#CCCCCC'}},
          {tag='Image',attributes={class='diceImage',image="ui_dice",tooltip="Killing roll",tooltipPosition="Above",color='#CCCCCC'}},
          {tag='Toggle',attributes={class='interactiveToggle', tooltip='6th Edition or not?', isOn='true', textColor='#FFFFFF'}},
          {tag='Text',attributes={class='cbdoRoll',onClick="cbdoRoll"}},
          {tag='Image',attributes={class='edit',onClick="cbreEditNow"}},
          {tag='InputField',attributes={class='UM',onEndEdit="textState",tooltip='Enter a dice modifier for this roll'}},
        }}
      }
end

function buildHSMUI()
  local minipanel = {
    tag='Panel', attributes={id="hsmpanel", allowDragging=true,returnToOriginalPositionWhenReleased=false,rectAlignment="UpperMiddle",offsetXY="0 200",padding="0 0 0 0", width=370, height=40},
    children={}
  }

  local miniui = {
      tag='TableLayout', attributes={active=true, id='hsmframe', visibility="black", autoCalculateHeight=true, ignoreLayout=true, offsetXY='0 0', width=370, rectAlignment='MiddleCenter', columnWidths="8 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 15 7", cellBackgroundColor='clear', cellPadding='2 2 2 2', color='#000000'},
      children={}
  }

  -- columnWidths='   15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15'
  -- columnWidths=" 8 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 15 7"
  -- columnWidths="30 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 5"
  --               1   2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23


  table.insert(miniui.children,
    {tag='Row', attributes={id='title',class="title", preferredHeight="16",height="16"},
      children={
        {tag='Cell', attributes={columnSpan=11}, children={
          {tag='Text',attributes={id="hsm", onClick="hsmClick",alignment="MiddleLeft", text="Hero <color=#BBBB00>System</color> Mod", tooltip="Hero <color=#BBBB00>System</color> Mod\n<i>v"..modVersion.."</i>", color="#CCCCCC"}}
        }},
        {tag='Cell', attributes={columnSpan=12}, children={
          {tag='Text',attributes={id="config", alignment="MiddleRight", text="Settings", tooltip="Configure H <color=#BBBB00>S</color> M",color="#555555", onClick="scactiveChar"}}
        }},
      }}
    )

  table.insert(miniui.children,
    {tag='Row', attributes={id='tabrow'},
      children={
          {tag='Cell', attributes={columnSpan=11}, children={
              {tag='Text',attributes={id="sceneTab", alignment="MiddleLeft", text=" Scene", tooltip="Scene Control\n<color=#888888>l-click: </color>View scene\n<color=#888888>r-click:</color>View scene", color="#CCCCCC",fontSize="18",fontStyle="Bold",onClick="scShow"}}
          }},
          {tag='Cell', attributes={columnSpan=12}, children={
              {tag='Text',attributes={state=false, id="combatTab", alignment="MiddleRight", text="Combat ", tooltip="Combat Control\n<color=#888888>l-click: </color>Add selected to combat\n<color=#888888>r-click:</color>Add all to combat",color="#555555",fontSize="18",fontStyle="Bold", onClick="scShow"}}
          }},
    }}
  )

  local holdScene = buildSceneUI()

  for k,uiContent in pairs(holdScene) do
    table.insert(miniui.children,uiContent)
  end

  table.insert(minipanel.children, miniui)
  return minipanel
end

function buildSceneUI()

    local miniui = {}

    local charListRowHeight=30

    local charlistRows = {}
    for i=1,maxLibSize do
      istring = twodigitnumber(i)
      table.insert(charlistRows, {tag='Row', attributes={active=true,id = istring..'row', preferredHeight=charListRowHeight},
        children={
            {tag='Cell', attributes={id = istring .. "linecell", columnSpan=2}, children={
              {tag='Text',attributes={onClick="scaddChar", class="slotNum", id = istring .. "line", text= "Add", tooltip="Click to add character"}}
            }},
            {tag='Cell', attributes={columnSpan=15}, children={
              {tag='Text',attributes={active = true, onClick="scaddChar", currentColor = "black", active="true", class="charname", id=istring .. "charname", text="Character", tooltip="Click to add character"}},
              {tag='InputField',attributes={onSubmit="sccharSubmit", textOffset="1 2 4 0",active=false, id=istring.."inputname", onEndEdit = "scgotName"}},
              --{tag='InputField',attributes={onSubmit="sccharSubmit", textOffset="1 2 8 0",active=false, id=istring.."inputname", onEndEdit = "scgotName" , onValueChanged = "scinputAutoHint"}},
            }},
            {tag='Cell', attributes={columnSpan=1}, children={
              {tag='Text',attributes={active = false, id=istring .. "active", text=crossMark, transition="None", color="#FFFFFF", tooltip = "Click to use in combat", fontStyle="Bold", onClick="dumpXML", combatState=false}},
            }},
          }}
      )
    end

    local charlistTable =  { tag="TableLayout",
      attributes={ class="charlist", id="charlisttable", rectAlignment="UpperLeft", columnWidths="15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15", cellBackgroundColor="#FFFFFF00",  cellPadding="2 2 2 2", color="#000000", autoCalculateHeight=true},
      children = charlistRows
    }

    local charlistVScroll = { tag="VerticalScrollView",
      attributes={ id="charListVS", scrollSensitivity=charListRowHeight*3, movementType="Clamped", color="#000000", scrollbarBackgroundColor="#333333", verticalScrollbarVisibility="AutoHide", inertia=false,onValueChanged="testFunc"},
      children = charlistTable
    }

    local charlistRow = {tag='Row',
      attributes={id='charlistrow', preferredHeight=(charListRowHeight*9)+4},
      children={{tag='Cell', attributes={columnSpan=23}, children=charlistVScroll}}
    }

    local playerIcons = {}
    table.insert(playerIcons,{tag='Cell'})
    table.insert(playerIcons,
    {tag='Cell',attributes={columnSpan=2},
    children={
      {tag='Image',attributes={image="ui_players", id="allplayers", color="#CCCCCC", tooltip = "All players\n<color=#888888>l-click: </color>Show all\n<color=#888888>r-click:</color>Show loaded", preserveAspect=true, onClick="scallPlayersClick" }},
    }}
    )
    for personcolour, person in pairs(players) do
      if personcolour != "black" then
        person.active = Player[personcolour].seated
        person.steam = iif(person.active,Player[personcolour].steam_name,"")
        table.insert(playerIcons,
          {tag='Cell', attributes={columnSpan=2},
            children={
              {tag='Image',attributes={
                image=iif(person.active,"ui_player","ui_noplayer"),
                id="player"..personcolour,
                color=shadeFail(person.active,person.color,"33"),
                tooltip = iif(person.active,
                  iif(Player[personcolour].steam_name,Player[personcolour].steam_name,"") .. "\nclick: assign colour\nright click: only show ",-- .. personcolour,
                  "<color="..person.color..">" .. firstToUpper(personcolour) .. " inactive</color>\n<color=#888888>l-click: </color>Assign/Remove colour\n<color=#888888>r-click:</color>Only show " .. personcolour
                  ),
                preserveAspect=true,
                onClick="scplayerIconClick"
              }},
            }}
        )
      end
    end
    table.insert(playerIcons,{tag='Cell'})

    local playerRow = {tag='Row',
      attributes={id='playerrow', preferredHeight="30", active=true},
      children=playerIcons
    }

    table.insert(miniui, playerRow)
    table.insert(miniui, charlistRow)
    table.insert(miniui,
      {tag='Row', attributes={id='activerow'},
        children={
            {tag='Cell', attributes={columnSpan=11}, children={
                {tag='Text',attributes={id="saveTab", alignment="MiddleLeft", text=" Save" .. halfSpace .."…", tooltip="Save Scene", onClick="scsaveScene", color="#CCCCCC",fontSize="18",}}
            }},
            {tag='Cell', attributes={columnSpan=11}, children={
                {tag='Text',attributes={id="loadTab", alignment="MiddleRight", text="…" ..halfSpace .. "Load ", tooltip="Load Scene", onClick="scloadScene", color="#CCCCCC",fontSize="18",}}
            }},
      }}
    )

    local oddCombatTable = { tag='TableLayout',
      attributes={active=true, id='turnUI', autoCalculateHeight=true, width=370, columnWidths='30 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20', cellBackgroundColor='clear', cellPadding='2 2 2 2', color='#050505', visibility="Black|Spades"},
      children=buildCombatUI()
    }
    -- 16 * 20 + 30 = 320 + 30 = 350
    --'30 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 5'
    --  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21
    local oddCombatVScroll = { tag="VerticalScrollView",
      attributes={ id="oddCombatVS", scrollSensitivity=68, color="#000000", scrollbarBackgroundColor="#333333", verticalScrollbarVisibility="AutoHide", transition="None", inertia=false },
      children = oddCombatTable
    }

    local oddCombatTurnRow = {tag='Row',
      attributes={id='oddCombatTurnRow', active=false, preferredHeight=40},
      children={
        {tag='Cell', attributes={columnSpan=3}, children={
          {tag='Text',attributes={id="turnClock", onClick="clockForward", fontSize=32,resizeTextForBestFit="true",resizeTextMinSize="30",resizeTextMaxSize="34", alignment="MiddleCenter", text=ccsegmentNumbers[12], tooltip="Click to advance a turn",color="#FFFFFF"}},
        }},
        {tag='Cell', attributes={columnSpan=19}, children={
            {tag='Text',attributes={id="turnText", color="#CCCCCC", fontSize=22, resizeTextForBestFit="true",resizeTextMinSize="20",resizeTextMaxSize="24", alignment="MiddleLeft", text="Click to begin combat", onClick="clockForward", tooltip="Click to begin combat"}}
        }},
      }
    }

    local oddCombatHeldRow = {tag='Row',
      attributes={id='oddCombatHeldRow', active=false, preferredHeight=34},
      children={
        {tag='Cell', attributes={columnSpan=22}, children={
          {tag='Text',attributes={active=true, id="heldRowText",resizeTextForBestFit="true",resizeTextMinSize="14",resizeTextMaxSize="20",color="#CCCCCC", fontSize=20, alignment="MiddleLeft", text=" Held: 0, Phasing: 0, Aborted: 0"}}
        }},
      }
    }

    local oddCombatRow = {tag='Row',
      attributes={id='oddCombatRow', preferredHeight=(12*34)+12, active=false},
      children={{tag='Cell', attributes={columnSpan=23}, children=oddCombatVScroll}}
    }

    local oddCombatEndRow = {tag='Row',
      attributes={id='oddCombatEndRow', active=false, preferredHeight=34},
      children={
        {tag='Cell', attributes={columnSpan=14}},
        {tag='Cell', attributes={columnSpan=10}, children={
          {tag='Button',attributes={interactable=true, onClick="endCombat", text=" <b>End Combat</b> ",id="endcombatText",color="#CCCCCC", fontSize=20, alignment="MiddleLeft", colors="#CCCCCC|#DDDDDD|#EEEEEE|#888888"}}
        }},
      }
    }
    table.insert(miniui, oddCombatTurnRow)
    table.insert(miniui, oddCombatHeldRow)
    table.insert(miniui, oddCombatRow)
    table.insert(miniui, oddCombatEndRow)
    return miniui
end

function buildBrowserUI(pre, character)
  -- BROWSER XML
  local miniui = {}
  local minipanel = {}

  local playerInfo = cbgetPlayerFromPre(pre)

  minipanel = {tag='Panel', attributes={active=false, id=pre .. "panel", visibility=playerInfo.desc, allowDragging=true,returnToOriginalPositionWhenReleased=false,rectAlignment="MiddleRight",offsetXY=playerInfo.offsetXY,padding="0 0 0 0", width=375, height=37},children={}}
  miniui = {tag='TableLayout', attributes={active=false, id=pre..'savedDiceRolls', visibility=playerInfo.desc,autoCalculateHeight=true, ignoreLayout=true, offsetXY='0 0', width=375, rectAlignment='MiddleCenter', offsetXY='0 0', columnWidths='15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15', cellBackgroundColor='clear', cellPadding='2 2 2 2', color='#000000'},children={}}

  --columnWidths='15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15',
  --columnWidths=' 1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25', = 25 * 15 = 375

  table.insert(miniui.children, {tag='Row', attributes={id=pre..'nameRow'},
    children={
      {tag='Cell', attributes={columnSpan=2}, children={
          {tag='Image', attributes={id=pre..'hero',image='ui_hero', onClick="doWork", tooltip="Jump to controller location", preserveAspect=true}}
      }},
      {tag='Cell', attributes={columnSpan=18}, children={
          {tag='Text', attributes={onClick="cbhideGlobal", id=pre..'title', color=playerInfo.color, alignment="MiddleLeft", text=" " ..character.name .. "⯇⯈", tooltip="Base Character",fontSize=18,resizeTextMaxSize=18,resizeTextMinSize=10,resizeTextForBestFit=true}}
      }},
      {tag='Cell', attributes={columnSpan=1}, children={
          {tag='Text', attributes={active="false",onClick="cbPrevInPool", id=pre..'poolPrevious', color="#CCCCCC", alignment="MiddleLeft", text="◄", tooltip="Previous character in pool",fontSize=18,resizeTextMaxSize=18,resizeTextMinSize=10,resizeTextForBestFit=true}}
      }},
      {tag='Cell', attributes={columnSpan=3}, children={
          {tag='Text', attributes={active="false",id=pre..'poolNumber', color="#CCCCCC", alignment="MiddleCenter", text="1/1", tooltip="Number of characters in pool",fontSize=18,resizeTextMaxSize=18,resizeTextMinSize=10,resizeTextForBestFit=true}}
      }},
      {tag='Cell', attributes={columnSpan=1}, children={
          {tag='Text', attributes={active="false",onClick="cbNextInPool", id=pre..'poolNext', color="#CCCCCC", alignment="MiddleLeft", text="►", tooltip="Next character in pool",fontSize=18,resizeTextMaxSize=18,resizeTextMinSize=10,resizeTextForBestFit=true}}
      }},

    }})

  for _,statState in pairs({"Primary","Secondary"}) do
    table.insert(miniui.children, cbmakeHeadRow(pre,24,"#999999",{statState},"["..statState.."]"))

    local count=1
    local statBuild = {}
    table.insert(statBuild,{tag='Cell'})

    for statName,v in pairs(statOrder) do
      local currentRow = math.ceil(count/4) -- 4 stats per row
      table.insert(statBuild,cbstatCellName (character.stats[statName], pre, statState))
      table.insert(statBuild,cbstatCellValue(character.stats[statName], pre, statState))
      if count%4 == 0 then  -- 4 stats per row
        table.insert(statBuild,{tag='Cell'})
        table.insert(miniui.children,
          {tag='Row', attributes={id=pre .. "statrow" .. string.lower(string.sub(statState, 1, 3)) ..currentRow, preferredHeight=26},
            children=statBuild
          }
        )
        statBuild = {}
        table.insert(statBuild,{tag='Cell'})
      end
      count = count + 1
    end
  end

  -- Make spacing for display 10 high with thin gray stripe
  table.insert(miniui.children, cbmakeHeadRow(pre,24,"#999999",{"Movement"},"[Movement]"))

  local moveOptions = {}
  local moveList = {"run","swim","leap","fly","glide","swing","teleport","tunnel"}
  table.insert(moveOptions,{tag='Cell'})
  table.insert(moveOptions,{tag='Cell'})
  for i,moveType in pairs(moveList) do
      if character.movement[moveType] then
          table.insert(moveOptions,
              {tag='Cell', attributes={columnSpan=2}, children={
                  {tag='Image', attributes={preserveAspect=true,active=iif(character.movement[moveType],true,false) ,onClick='cbmoveSelection('..moveType..')', id=pre.. moveType, image=character['movement'][moveType]['icon'], tooltip=moveType .. ": ".. character['movement'][moveType]['combat'] .. " / ".. character['movement'][moveType]['noncombat'], padding="0 0 0 0"}}
              }}
          )
      else
          table.insert(moveOptions,
              {tag='Cell', attributes={columnSpan=2}, children={
                  {tag='Image', attributes={preserveAspect=true,active=iif(character.movement[moveType],true,false) ,onClick='cbmoveSelection('..moveType..')', id=pre.. moveType, image="ui_run", tooltip="", padding="0 0 0 0"}}
              }}
          )
      end
  end
  table.insert(moveOptions,{tag='Cell',attributes={columnSpan=2}})

  local moveRow = {tag='Row', attributes={id=pre.. "moverow"}, children=moveOptions}
  table.insert(miniui.children, moveRow)

  -- Make spacing for display 10 high with thin gray stripe
  table.insert(miniui.children, cbmakeHeadRow(pre,24,"#999999",{"Change"},"[Change]"))
  local changeOptions = {}
  for i,stat in pairs(statList) do
      table.insert(changeOptions,{tag='Option', value=character.stats[stat].name})
  end
  local changeRow1 = {tag='Row', attributes={id=pre.. "changerow1"},
          children={
              {tag='Cell',attributes={columnSpan=1}},
              {tag='Cell',attributes={columnSpan=14},
              children={
                  {tag='Dropdown', attributes={id=pre..'changeDrop',resizeTextForBestFit=true,resizeTextMinSize=8,resizeTextMaxSize=15,checkColor="#FFFFFF",scrollbarColors='#666666|#666666|#222222|#FF0000',itemBackgroundColors='#000000|#666666|#000000|#000000',arrowColor="#FFFFFF",color="#000000",textColor="#FFFFFF", dropdownBackgroundColor="#000000",onValueChanged="cbgetChange"},
                  children=changeOptions}
              }},
              {tag='Cell', attributes={columnSpan=3},children={
                  {tag='InputField', attributes={text=10, whichStat="str", class = 'ii3', tooltip='Enter a changed value for this stat', id=pre..'statChange', onEndEdit="cbupdateChangeMod"}}
              }},
              {tag='Cell', attributes={columnSpan=2}, children={}},
          }}
  table.insert(miniui.children, changeRow1)

  local changeRow2 = {tag='Row', attributes={id=pre.. "changerow2"},
          children = {
              {tag='Cell'},{tag='Cell'},
              {tag='Cell',attributes={columnSpan='9'}, children = {
                  {tag='Button',value='Restore STR', attributes={whichStat="str", active=true, id=pre.."cbrestoreStat",onClick="cbrestoreStat",alignment='MiddleCenter',colors='#EEEEEE|#F8F8F8|#FFFFFF|rgba(0.78,0.78,0.78,0.5)',fontStyle='Bold',textColor='#000000',tooltip='Click to restore Strength to original value'}}
                  }},
              {tag='Cell',attributes={columnSpan='7'}, children = {
                  {tag='Button',value='Change', attributes={whichStat="str",id=pre.."cbchangeStat",onClick="cbchangeStat",alignment='MiddleCenter',colors='#EEEEEE|#F8F8F8|#FFFFFF|rgba(0.78,0.78,0.78,0.5)',fontStyle='Bold',textColor='#000000',tooltip='Click to change Strength to selected value'}}
                  }},
              {tag='Cell'},{tag='Cell'}
          }
      }
  table.insert(miniui.children, changeRow2)

  -- Make spacing for display 10 high with thin gray stripe
  table.insert(miniui.children, cbmakeHeadRow(pre,24,"#999999",{"Distance"},"[Distance]"))

  local distanceOptions = {}
  table.insert(distanceOptions,{tag='Cell'})
  table.insert(distanceOptions,{tag='Cell',attributes={columnSpan=2},children={
      {tag='Image', attributes={ id=pre..'distCheck1',image="ui_player", onClick="cbdistCheck", tooltip="Check distance between two selected items"}}
  }})
  table.insert(distanceOptions,{tag='Cell',attributes={columnSpan=1},children={
      {tag='text', attributes={id=pre..'distCheck2',resizeTextMaxSize=14,resizeTextMinSize=9,resizeTextForBestFit=true,onClick="cbdistCheck", text="→", color = "#CCCCCC", tooltip="Check distance between two selected items",tooltipPosition='Above'}}
  }})
  table.insert(distanceOptions,{tag='Cell',attributes={columnSpan=2},children={
      {tag='Image', attributes={id=pre..'distCheck3', image="ui_player", onClick="cbdistCheck", tooltip="Check distance between two selected items"}}
  }})
  table.insert(distanceOptions,{tag='Cell'})
  table.insert(distanceOptions,{tag='Cell',attributes={columnSpan=4},children={
      {tag='InputField', attributes={text=0, fontSize="13",class = 'ii3', characterLimit=5, tooltip="Distance <i>'a'</i>  in Metres", id=pre..'statWidthMod', onEndEdit="cbupdateDist",navigation="Explicit",selectOnDown=pre..'statHeightMod',selectOnRight=pre..'statHeightMod',selectOnUp=pre..'statWidthMod',selectOnLeft=pre..'statWidthMod'}}
  }})
  table.insert(distanceOptions,{tag='Cell',attributes={columnSpan=1},children={
      {tag='text', attributes={resizeTextMaxSize=14,resizeTextMinSize=9,resizeTextForBestFit=true, text="+", color = "#CCCCCC"}}
  }})
  table.insert(distanceOptions,{tag='Cell',attributes={columnSpan=4},children={
      {tag='InputField', attributes={text=0, fontSize="13",class = 'ii3', characterLimit=5, tooltip="Distance <i>'b'</i>  in Metres", id=pre..'statHeightMod', onEndEdit="cbupdateDist",navigation="Explicit",selectOnDown=pre..'pythagMod',selectOnRight=pre..'pythagMod',selectOnUp=pre..'statWidthMod',selectOnLeft=pre..'statWidthMod'}}
  }})
  table.insert(distanceOptions,{tag='Cell',attributes={columnSpan=1},children={
      {tag='text', attributes={text="=", color = "#CCCCCC", tooltip="Upto 8m=<i>+0</i>, 12m=<i>-1</i>, 16m=<i>-2</i>, 24m=<i>-3</i>, 32m=<i>-4</i>, 48m=<i>-5</i>, 64m=<i>-6</i>, 96m=<i>-7</i>, 128m=<i>-8</i>",tooltipPosition='Above'}}
  }})
  table.insert(distanceOptions,{tag='Cell',attributes={columnSpan=5},children={
      {tag='InputField', attributes={text=0, fontSize="14",class = 'ii3', characterLimit=6, tooltip="Distance <i>'c'</i>  in Metres", id=pre..'pythagMod', onEndEdit="cbreverseupdateDist",navigation="Explicit",selectOnDown=pre..'pythagMod',selectOnRight=pre..'pythagMod',selectOnUp=pre..'statHeightMod',selectOnLeft=pre..'statHeightMod'}}
  }})
  table.insert(distanceOptions,{tag='Cell',attributes={columnSpan=4},children={
      {tag='Toggle', attributes={text="0", color = "#CCCCCC",textColor="#CCCCCC", id=pre..'rangeMod', tooltip="Use Range Modifier?", isOn=false, onValueChanged="cbupdateRangeMod",tooltipPosition='Above'}}
  }})
  local distanceRow = {tag='Row', attributes={id=pre.. "distancerow"}, children=distanceOptions}
  table.insert(miniui.children, distanceRow)

  -- Make spacing for display 10 high with thin gray stripe
  table.insert(miniui.children, cbmakeHeadRow(pre,24,"#999999",{"SkillRolls"},"[Skill Rolls]"))

  -- SKILLS
  local skillRow = {}
  local numSkillPages = math.ceil(#character.skills / 3)
  local currentSkillPage = 1
  local startSkill = 1
  local i = startSkill

  for currentRow = 1,3 do
      local toolText,thisRoll,thisName,showFlag = "", "","",false
      if i <= #character.skills then
          toolText = character.skills[i].tool
          thisRoll = character.skills[i].roll
          thisName = character.skills[i].name
          showFlag = true
          whichList = 'skills'
      end
      skillRow = {tag='Row', attributes={id=pre.."skillsRow"..currentRow,active=true},
          children ={
              {tag='Cell', attributes={columnSpan=1}},
              {tag='Cell', attributes={columnSpan=2}, children={
                  {tag='Image', attributes={list=whichList,active=showFlag,class='targetImage', id=pre.."skimg"..currentRow, tooltip=toolText}}
              }},
              {tag='Cell', attributes={columnSpan=17}, children={
                  {tag='Text', attributes={list=whichList,active=showFlag,class='rollDesc cbdoRoll',listIdx=i,row=currentRow, id=pre..'skdesc'..currentRow,text=" " .. thisName,tooltip=toolText}}
              }},
              {tag='Cell', attributes={columnSpan=3},children={
                  {tag='InputField', attributes={list=whichList,active=showFlag,class = 'ii3 UM', listIdx=i,row=currentRow,tooltip='Enter a dice modifier for the '.. thisName.. ' roll', id=pre..'skmod'..currentRow}}
              }},
          }}
      if currentRow == 1 then
          table.insert(skillRow.children, {tag='Cell', attributes={columnSpan=2},children={
              {tag='Image', attributes={list=whichList,id=pre.. "skctlimg"..currentRow, listIdx=i,row=currentRow,onClick="cbsetChange",active=false,image="ui_arrow_u", tooltip="Previous set " .. (currentSkillPage - 1) .. " of " .. numSkillPages, color="#CCCCCC",preserveAspect=false}},
              {tag='Text', attributes={list=whichList,id=pre.. "skctltxt"..currentRow,listIdx=i,row=currentRow,text="", tooltip="",fontSize=12,resizeTextForBestFit=true,resizeTextMinSize=9,resizeTextMaxSize=12, active=false}},
          }})
      elseif currentRow == 2 then
          table.insert(skillRow.children,{tag='Cell', attributes={columnSpan=2},children={
              {tag='Image', attributes={list=whichList,id=pre.. "skctlimg"..currentRow, listIdx=i,row=currentRow,onClick="",active=false,image="ui_arrow_u", tooltip="", color="#CCCCCC"}},
              {tag='Text', attributes={list=whichList,id=pre.. "skctltxt"..currentRow,listIdx=i,row=currentRow,text=currentSkillPage .. "/" .. numSkillPages, color="#CCCCCC", tooltip="Set ".. currentSkillPage .. " of " .. numSkillPages,fontSize=12,resizeTextForBestFit=true,resizeTextMinSize=9,resizeTextMaxSize=12 }},
          }})
      elseif currentRow == 3 then
          table.insert(skillRow.children,{tag='Cell', attributes={columnSpan=2},children={
              {tag='Image', attributes={list=whichList,id=pre.. "skctlimg"..currentRow,listIdx=i,row=currentRow,onClick="cbsetChange",active=iif(currentSkillPage>=numSkillPages,false,true),image="ui_arrow_d", tooltip="Next set " .. (currentSkillPage + 1) .. " of " .. numSkillPages,tooltipPosition="Below", color="#CCCCCC",preserveAspect=false}},
              {tag='Text', attributes={list=whichList,id=pre.. "skctltxt"..currentRow,listIdx=i,row=currentRow,text="", tooltip="",fontSize=12,resizeTextForBestFit=true,resizeTextMinSize=9,resizeTextMaxSize=12, active=false}},
          }})
      end
      table.insert(miniui.children, skillRow)
      i = i + 1
  end

  -- Make spacing for display 10 high with thin gray stripe
  table.insert(miniui.children, cbmakeHeadRow(pre,24,"#999999",{"Maneuver"},"[Martial Arts]"))

  local martialRow = {}
  local numMartialPages = math.ceil(#character.martialArts / 3)
  local currentMartialPage = 1
  local startMartial = 1 + ((currentMartialPage - 1) * 3)
  local i = startMartial
  local whichList = "ma"
  local thisTool,thisRoll,thisName,showFlag = "", "","",false

  for currentRow = 1,3 do
      local toolText,thisRoll,thisName,showFlag = "", "","",false
      local whichList = 'martialArts'
      if i <= #character.martialArts then
          toolText = character.martialArts[i].tool
          thisRoll = character.martialArts[i].roll
          thisName = character.martialArts[i].name
          showFlag = true
      end
      martialRow = {tag='Row', attributes={id=pre.."martialsRow"..currentRow,active=true},
          children ={
              {tag='Cell', attributes={columnSpan=1}},
              {tag='Cell', attributes={columnSpan=2}, children={
                  {tag='Image', attributes={list=whichList,active=showFlag,class='crosshairImage', id=pre.."maimg"..currentRow, tooltip=toolText}}
              }},
              {tag='Cell', attributes={columnSpan=17}, children={
                  {tag='Text', attributes={list=whichList,active=showFlag,class='rollDesc cbdoRoll',listIdx=i,row=currentRow, id=pre..'madesc'..currentRow,text=" " .. thisName,tooltip=toolText}}
              }},
              {tag='Cell', attributes={columnSpan=3},children={
                  {tag='InputField', attributes={list=whichList,active=showFlag,class = 'ii3 UM', listIdx=i,row=currentRow,tooltip='Enter a dice modifier for the '.. thisName.. ' roll', id=pre..'mamod'..currentRow}}
              }},
          }}
      if currentRow == 1 then
          table.insert(martialRow.children, {tag='Cell', attributes={columnSpan=2},children={
              {tag='Image', attributes={list=whichList,id=pre.. "mactlimg"..currentRow, listIdx=i,row=currentRow,onClick="cbsetChange",active=false,image="ui_arrow_u", tooltip="Previous set " .. (currentMartialPage - 1) .. " of " .. numMartialPages, color="#CCCCCC",preserveAspect=false}},
              {tag='Text', attributes={list=whichList,id=pre.. "mactltxt"..currentRow, listIdx=i,row=currentRow,text="", tooltip="",fontSize=12,resizeTextForBestFit=true,resizeTextMinSize=9,resizeTextMaxSize=12, active=false}},
          }})
      elseif currentRow == 2 then
          table.insert(martialRow.children,{tag='Cell', attributes={columnSpan=2},children={
              {tag='Image', attributes={list=whichList,id=pre.. "mactlimg"..currentRow, listIdx=i,row=currentRow,onClick="",active=false,image="ui_arrow_u", tooltip="", color="#CCCCCC"}},
              {tag='Text', attributes={list=whichList,id=pre.. "mactltxt"..currentRow,listIdx=i,row=currentRow,text=currentMartialPage .. "/" .. numMartialPages, color="#CCCCCC", tooltip="Set ".. currentMartialPage .. " of " .. numMartialPages,fontSize=12,resizeTextForBestFit=true,resizeTextMinSize=9,resizeTextMaxSize=12 }},
          }})
      elseif currentRow == 3 then
          table.insert(martialRow.children,{tag='Cell', attributes={columnSpan=2},children={
              {tag='Image', attributes={list=whichList,id=pre.. "mactlimg"..currentRow,listIdx=i,row=currentRow,onClick="cbsetChange",active=iif(currentMartialPage<numMartialPages, true,false),image="ui_arrow_d", tooltip="Next set " .. (currentMartialPage + 1) .. " of " .. numMartialPages, tooltipPosition="Below", color="#CCCCCC", preserveAspect=false}},
              {tag='Text', attributes={list=whichList,id=pre.. "mactltxt"..currentRow,listIdx=i,row=currentRow,text="", tooltip="",fontSize=12,resizeTextForBestFit=true,resizeTextMinSize=9,resizeTextMaxSize=12, active=false}},
          }})
      end
      table.insert(miniui.children, martialRow)
      i = i + 1
  end
  -- Make spacing for display 10 high with thin gray stripe
  table.insert(miniui.children, cbmakeHeadRow(pre,24,"#999999",{"Location"},"[Location]"))

  local locationOptions = {}

  for i,location in pairs(locationTables) do
      table.insert(locationOptions,{tag='Option',value=location.name})
  end
  currentLocation = locationTables[1]
  local locationRow = {tag='Row', attributes={id=pre.. "locationrow"},
          children={
              {tag='Cell'},
              {tag='Cell',attributes={columnSpan=19},
              children={
                  {tag='Dropdown', attributes={tooltip=locationTables[1].tool, id=pre..'locationDrop',resizeTextForBestFit=1,resizeTextMinSize=10,resizeTextMaxSize=15,checkColor="#FFFFFF",scrollbarColors='#666666|#666666|#222222|#FF0000',itemBackgroundColors='#000000|#666666|#000000|#000000',arrowColor="#FFFFFF",color="#000000",textColor="#FFFFFF", dropdownBackgroundColor="#000000",columnSpan=14,onValueChanged="cbsetLocation()"},
                  children=locationOptions}
              }},
              {tag='Cell', attributes={columnSpan=3},children={
                  {tag='InputField', attributes={text=0,class = 'ii3', tooltip='Enter a dice modifier for this roll', id=pre..'statLocationMod', onEndEdit="textState"}}
              }},
              {tag='Cell', attributes={columnSpan=2}, children={
                  {tag='Image', attributes={image='ui_dice', onClick="cbdoRoll", id=pre..'locationRoll', preserveAspect=true}}
              }}
          }}
  table.insert(miniui.children, locationRow)

  -- Make spacing for display 10 high with thin gray stripe
  table.insert(miniui.children, cbmakeHeadRow(pre,24,"#999999",{"DiceRolls"},"[Dice Rolls]"))

  --local sizeOfRollList = tablelength(rollList)
  local diceOptions = {}

  for i,details in pairs(character.rollList) do

      local iconToUse="dice"
      if details.toHit then
           iconToUse = "crosshair"
      elseif
          details.killingAttack then iconToUse = "skull"
      elseif
          details.targetCheck then iconToUse = "target"
      end

      table.insert(diceOptions,{tag='Row', attributes={id=pre..'Row'..i ,active=true},
          children ={
              {tag='Cell', attributes={columnSpan=2}, children={
                  {tag='Image', attributes={class=iconToUse .. 'Image edit',id=pre..'edit'..i}}
              }},
              {tag='Cell', attributes={columnSpan=17},
                  children={
                      {tag='Text', attributes={class='rollDesc cbdoRoll' , tooltip=details.tool, text=" "..details.name, id=pre..'rollSave'..i}}
              }},
              {tag='Cell', attributes={columnSpan=3},
                  children={
                      {tag='InputField', attributes={class = 'ii3 UM',id=pre..'saveMod'..i}}
              }},
              {tag='Cell',attributes={columnSpan=2}}
          }})
  end

  for i = #character.rollList+1,40 do
      table.insert(diceOptions,{tag='Row', attributes={id=pre..'Row'..i ,active=false},
          children ={
              {tag='Cell', attributes={columnSpan=2}, children={
                  {tag='Image', attributes={class='skullImage edit',id=pre..'edit'..i}}
              }},
              {tag='Cell', attributes={columnSpan=17},
                  children={
                      {tag='Text', attributes={class='rollDesc cbdoRoll',id=pre..'rollSave'..i}}
              }},
              {tag='Cell', attributes={columnSpan=3},
                  children={
                      {tag='InputField', attributes={class = 'ii3 UM',id=pre..'saveMod'..i}}
              }},
              {tag='Cell',attributes={columnSpan=2}}
          }})
  end

  local finalDiceRow = {tag='Row', attributes={id=pre.. "diceRow", preferredHeight=math.min((#character.rollList*34) + 6,176) },
          children={
              {tag='Cell'},
              {tag='Cell',attributes={columnSpan=24},
              children={
                  {tag='VerticalScrollView', attributes={id=pre..'verticalScroller',scrollSensitivity=15, movementType="Clamped", height=110,preferredHeight=110, color="#000000",scrollbarBackgroundColor="#333333",verticalScrollbarVisibility="AutoHide"},
                  children={
                      {tag='TableLayout', attributes={rectAlignment="UpperLeft",columnWidths='15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15',id=pre..'diceTable', cellBackgroundColor='clear', cellPadding='2 2 2 2', color='#000000',  preferredHeight=(#character.rollList*34), height=(#character.rollList*34)},
                      children = diceOptions
                      }
                  }}
              }}
          }
      }

  table.insert(miniui.children, finalDiceRow)
  table.insert(miniui.children, cbmakeHeadRow(pre,24,"#999999",{"RollMaker"},"[Roll Maker]"))

  local createDoing =
      {tag='Row', attributes={id=pre.."createDoing",active=true, preferredHeight=1,},children = {
          {tag='Cell'},
          {tag='Cell', attributes={columnSpan=18},children= {
              {tag='Text',value='Create a new Roll ...', attributes={id=pre.."newRollTitle" ,fontStyle='Bold', color="#CCCCCC", alignment="MiddleLeft"}}
          }},
          {tag='Cell', attributes={columnSpan=2}, children={
              {tag='Image', attributes={id=pre.."moveUp",active=false, image="Sprites/Icons/Arrow_Up",tooltip="Move dice roll up",tooltipPosition="Above",preserveAspect=true}}
          }},
          {tag='Cell', attributes={columnSpan=2}, children={
              {tag='Image', attributes={id=pre.."moveDn",active=false, image="Sprites/Icons/Arrow_Down",tooltip="Move dice roll down",tooltipPosition="Above",preserveAspect=true}}
          }},
          }
      }

  local typeRow =
    {tag='Row', attributes={id=pre.."typeRow",active=true}, children={
      {tag='Cell'},
      {tag='Cell',attributes={columnSpan=17}, children={
        {tag='ToggleGroup', children={
          {tag='HorizontalLayout',attributes={spacing=2}, children={
            {tag='Toggle', value='Damage', attributes={id=pre.."damageTog",  onValueChanged="cbshowRollBlock", textColor='#CCCCCC', tooltip='Create a damage dice roll', isOn=true}},
            {tag='Toggle', value='Target', attributes={id=pre.."targetTog",  onValueChanged="cbshowRollBlock", textColor='#CCCCCC', tooltip='Create a target dice roll', isOn=false}},
            {tag='Toggle', value='To Hit', attributes={id=pre.."tohitTog",   onValueChanged="cbshowRollBlock", textColor='#CCCCCC', tooltip='Create a to hit dice roll', isOn=false}},
          }}
        }}
      }},
      {tag='Cell',attributes={columnSpan=5}, children={
        {tag='Button', value='Roll Now', attributes={fontStyle="Bold", onClick="cbreRollNow", id=pre..'cbreRollNow', tooltip="Click to roll now"}}
      }},
      {tag='Cell', attributes={columnSpan=2}, children={
          {tag='Image', attributes={image='ui_dice', onClick="cbreRollNow", id=pre..'cbreRollNow', preserveAspect=true}}
      }}
    }}

  local typeLineRow =
    {tag='Row', attributes={id=pre.."typeLineRow",active=true, preferredHeight=1}, children={
      {tag='Cell'},
      {tag='Cell',attributes={columnSpan=22, color="#222222",cellBackgroundColor="#222222",dontUseTableCellBackground=true}},
      {tag='Cell'},
    }}
  local spaceLineRow =
    {tag='Row', attributes={id=pre.."spaceLineRow",active=true, preferredHeight=5}, children={
      --      {tag='Cell',attributes={columnSpan=24}},
    }}

  local diceRow =
      {tag='Row',attributes={id=pre.."diceMakeRow",active=true,preferredHeight=34},children={
        {tag='Cell'},
        {tag='Cell',attributes={columnSpan=2},children={
          {tag='Button', attributes={id=pre.. "cbrelowerDice",text="-", fontSize = 18, textColor="#CCCCCC", onClick="cbreChangeDice", colors='#222222|#444444|#222222|#222222',tooltip="Remove one from the number of dice",tooltipPosition="Above"}}
        }},
        {tag='Cell', attributes={columnSpan=3},children={
          {tag='InputField', attributes={textOffset="2 2 2 2", textAlignment="MiddleCenter", characterLimit=2, text="3", characterValidation='Integer',class = 'ii3', fontSize=18, tooltip='Enter a dice modifier for this roll', id=pre..'inputDice', onEndEdit="cbreDiceNumber", overrideGlobalCellPadding=true, padding="0 0 0 0", tooltip="Enter the number of dice for the roll",tooltipPosition="Above",navigation="Explicit",selectOnDown=pre.. "cbreDiceMod",selectOnRight=pre.. "cbreDiceMod"}}
        }},
        {tag='Cell',attributes={columnSpan=2},children={
          {tag='Button', attributes={id=pre.. "cbreraiseDice",text="+", fontSize = 18, textColor="#CCCCCC", onClick="cbreChangeDice", colors='#222222|#444444|#222222|#222222', tooltip="Add one to the number of dice",tooltipPosition="Above"}}
        }},
        {tag='Cell'},
        {tag='Cell',attributes={columnSpan=5},children={
          {tag='Toggle',value=' +½d6',attributes={active=true,id=pre.. "cbreHalfSwitch",onValueChanged="toggleState",textColor='#FFFFFF',tooltip='Add ½d6 to the roll',isOn=false}}
        }},
        {tag='Cell', attributes={columnSpan=6},children= {
          {tag='Text',value='Dice Modifier', attributes={color="#CCCCCC", alignment="MiddleRight"}}
        }},
        {tag='Cell',attributes={columnSpan=3},children={
          {tag='InputField',attributes={id=pre.. "cbreDiceMod",onEndEdit="textState",class='ii3',placeholder='Mod',tooltip='Enter a dice modifier for the roll', text="0",navigation="Explicit",selectOnDown=pre.. "cbreStunMod", selectOnRight=pre.. "cbreStunMod",selectOnUp=pre.. "cbreStunMod", selectOnLeft=pre.. "cbreStunMod"}}
        }},
        }
      }

  local killingRow =
    {tag='Row', attributes={id=pre.."killingRow",active=true,preferredHeight=34}, children={
      {tag='Cell'},
      {tag='Cell',attributes={columnSpan=8,}, children={
        {tag='Toggle', value='Std. Effect?',attributes={active=true,id=pre.."standardTog",    onValueChanged="toggleState", textColor='#CCCCCC', tooltip='Use Standard effect for this roll',}},
      }},
      {tag='Cell',attributes={columnSpan=5,}, children={
        {tag='Toggle', value='Killing?',attributes={active=true,id=pre.. "cbreKillSwitch",onValueChanged="toggleState",textColor='#CCCCCC',tooltip='Make into a Killing dice damage roll', isOn=false}}
      }},
      {tag='Cell', attributes={columnSpan=6},children= {
        {tag='Text',value='Stun Modifier ', attributes={color="#CCCCCC", alignment="MiddleRight"}}
      }},
      {tag='Cell',attributes={columnSpan=3},children={
        {tag='InputField',attributes={id=pre.."cbreStunMod",onEndEdit="textState",class='ii3',placeholder='Stun Mult',tooltip='Stun Multiplier Modifier', text=getNumber(stunMult), navigation="Explicit",selectOnDown=pre.. "cbreToolInput", selectOnRight=pre.. "cbreToolInput",selectOnUp=pre.. "cbreDiceMod", selectOnLeft=pre.. "cbreDiceMod"}}
      }},
    }}

  local statOptions = {{tag='Text', value='Roll against',attributes={alignment="MiddleLeft", color="#999999", verticalOverflow="Overflow", textColor='#CCCCCC', tooltip='Choose something for the target number roll',}}}
  table.insert(statOptions,{tag='Toggle', value='Number',attributes={verticalOverflow="Overflow", id=pre.."target" .. "num" .. "Tog",    onValueChanged="cbtargetChoice", textColor='#CCCCCC', tooltip='Choose a base number for the target number roll',isOn=true}})
  for name,detail in pairs(statOrder) do
    if detail.base then
      table.insert(statOptions,{tag='Toggle', value=string.upper(name) ,attributes={id=pre.."target" ..name .. "Tog",    onValueChanged="cbtargetChoice", textColor='#CCCCCC', tooltip='Choose ' .. detail.fullName ..' for the target number roll',}})
    end
  end

  local targetBaseRow = --preferredHeight="60"
  {tag='Row', attributes={id=pre.."targetBaseRow",active=true, preferredHeight=60}, children = {
    {tag='Cell',attributes={columnSpan=1}},
    {tag='Cell',attributes={columnSpan=24}, children={
      {tag='ToggleGroup', children={
        {tag='GridLayout',attributes={id=pre.."gridBase", spacing=4, cellSize="87 24" ,constraintCount=4, constraint="FixedColumnCount"}, children=statOptions}
      }}
    }},
  }}

  local targetRow =
    {tag='Row', attributes={id=pre.."targetRow",active=true, preferredHeight=34},
      children = {
        {tag='Cell',attributes={columnSpan=1}},
        {tag='Cell', attributes={columnSpan=7},children= {
          {tag='Text',value='Target Number', attributes={id=pre.."cbreTargetText",color="#999999", alignment="MiddleLeft"}}
        }},
        {tag='Cell',attributes={columnSpan=3}, children = {

          {tag='InputField', attributes={text="0", id=pre.."cbreTargetNumber",onEndEdit="textState", class='ii3',placeholder='0',tooltip='Target Number to roll less than or equal too'}},
          {tag='Text',value='Stat', attributes={id=pre.."cbreTargetStat",active=false, color="#999999", alignment="MiddleLeft"}},
        }},
        {tag='Cell', attributes={columnSpan=9},children= {
          {tag='Text',value='Target Modifier ', attributes={color="#999999", alignment="MiddleRight"}}
        }},
        {tag='Cell',attributes={columnSpan=3}, children = {
          {tag='InputField', attributes={text="0",id=pre.."cbreTargetRowMod",onEndEdit="textState", class='ii3',tooltip='Target roll Modifier'}}
        }},
      }
    }

  local toHitRow =
    {tag='Row', attributes={id=pre.."toHitRow",active=true, preferredHeight=34},
      children = {
        {tag='Cell'},
        {tag='Cell',attributes={columnSpan=12, active=true, id=pre.."ocvChoice"}, children={
          {tag='ToggleGroup', children={
            {tag='HorizontalLayout',attributes={spacing=20}, children={
              {tag='Toggle',value='OCV',  attributes={id=pre.. "cbreOCVSwitch",onValueChanged="toggleState",textColor='#FFFFFF',tooltip='Use Offensive Combat Value (OCV)', isOn=true}},
              {tag='Toggle',value='OMCV', attributes={id=pre.. "cbreOMCVSwitch",onValueChanged="toggleState",textColor='#FFFFFF',tooltip='Use Offensive Mental Combat Value (OMCV)', isOn=false}},
            }}
          }}
        }},
        {tag='Cell', attributes={columnSpan=7},children= {
          {tag='Text',value='CV Modifier ', attributes={color="#999999", alignment="MiddleRight",tooltip='Combat value roll modifier'}}
        }},
        {tag='Cell',attributes={columnSpan=3}, children = {
          {tag='InputField', attributes={text="0",id=pre.."cbreCVMod",onEndEdit="textState", class='ii3',tooltip='Combat value roll modifier',navigation="Explicit", selectOnDown=pre.."cbreRangedMod", selectOnRight=pre.."cbreRangedMod", selectOnUp=pre.."cbreRangedMod", selectOnLeft=pre.."cbreRangedMod"}}
        }},
      }
    }

    local toHitTwoRow =
      {tag='Row', attributes={id=pre.."toHitTwoRow",active=true, preferredHeight=34},
        children = {
          {tag='Cell'},
          {tag='Cell',attributes={columnSpan=6}, children={
            {tag='Toggle',value='Ranged?',attributes={fontSize=13, textColor="#999999", onValueChanged="toggleState",id=pre..'cbreRangedSwitch',class='interactiveToggle', isOn=true, tooltip="Use Ranged Modifiers with this roll"}},
          }},
          {tag='Cell', attributes={columnSpan=4},children= {
            {tag='Text',value='Modifier ', attributes={fontSize=13,color="#999999", alignment="MiddleRight", tooltip="Ranged Modifier to use with this roll"}}
          }},
          {tag='Cell',attributes={columnSpan=3}, children = {
            {tag='InputField', attributes={text="0",id=pre.."cbreRangedMod",onEndEdit="textState", class='ii3',tooltip='Combat Value Modifier',navigation="Explicit", selectOnDown=pre.."cbreDCVMod",selectOnUp=pre.. "cbreCVMod",selectOnLeft=pre.."cbreCVMod",selectOnRight=pre.. "cbreDCVMod"}}
          }},
          {tag='Cell', attributes={columnSpan=6},children= {
            {tag='Text',value='DCV Modifier ', attributes={fontSize=13,color="#999999", alignment="MiddleRight", tooltip='Defensive Combat Value Modifier'}}
          }},
          {tag='Cell',attributes={columnSpan=3}, children = {
            {tag='InputField', attributes={text="0",id=pre.."cbreDCVMod",onEndEdit="textState", class='ii3',tooltip='Defensive Combat Value Modifier',navigation="Explicit", selectOnDown=pre.."cbreToolInput",selectOnUp=pre.. "cbreRangedMod", selectOnRight=pre.. "cbreToolInput",selectOnLeft=pre.. "cbreRangedMod"}}
          }},
          {tag='Cell'},
        }
      }

  local moreRow =
    {tag='Row', attributes={id=pre.."moreRow",preferredHeight=34,active=true},
      children = {
        {tag='Cell'},
        {tag='Cell',attributes={columnSpan=11,},children={
          {tag='Text',value='Save …', attributes={id=pre.."cbrePossibleSave",fontSize=13,color="#999999", alignment="MiddleLeft", tooltip="Click here to save …",onClick="cbrePossibleSave"}},
        }},
        {tag='Cell',attributes={columnSpan=11,},children={
          {tag='Text',value='… Reset', attributes={id=pre.."cbreReset",onClick="cbreCancelNow",fontSize=13,color="#999999", alignment="MiddleRight", tooltip="Click here to reset …"}},
        }},
      }
    }

  local toolRow =
      {tag='Row', attributes={id=pre.."toolRow",active=true,preferredHeight=1},
          children = {
              {tag='Cell'},
              {tag='Cell', attributes={columnSpan=5},children= {
                  {tag='Text',value='Tooltip', attributes={color="#999999", alignment="MiddleLeft"}}
              }},
              {tag='Cell',attributes={columnSpan=17}, children = {
                  {tag='InputField', attributes={id=pre.. "cbreToolInput", onEndEdit="textState", placeholder='Enter a tooltip for the roll',tooltip='Enter a tooltip for the roll', text="",selectOnDown=pre.. "cbreSaveName", selectOnRight=pre.. "cbreSaveName"}}
                  }},
              {tag='Cell'},{tag='Cell'}
          }
      }

  local saveNameRow =
      {tag='Row', attributes={id=pre.."saveNameRow",active=true,preferredHeight=1},
          children = {
              {tag='Cell'},
              {tag='Cell', attributes={columnSpan=5},children= {
                  {tag='Text',value='Save Name', attributes={color="#999999", alignment="MiddleLeft"}}
              }},
              {tag='Cell',attributes={columnSpan=17}, children = {
                  {tag='InputField', attributes={id=pre.. "cbreSaveName",onEndEdit="textState",characterLimit='100',colors='#EEEEEE|#F8F8F8|#FFFFFF|rgba(0.78,0.78,0.78,0.5)',placeholder='Enter Save Name',textColor='#000000',tooltip='Enter a name to save as', text=saveName, navigation="Explicit",selectOnUp=pre.. "cbreToolInput",selectOnDown=pre.. "cbreToolInput", selectOnRight=pre.. "cbreToolInput",selectOnLeft=pre.. "cbreToolInput"}}
                  }},
              {tag='Cell'},{tag='Cell'}
          }
      }

  local saveDeleteRow =
      {tag='Row', attributes={id=pre.."deleteSaveCancelRow", active=true,preferredHeight=1},
          children = {
              {tag='Cell'},
              {tag='Cell',attributes={columnSpan='7'}, children = {
                  {tag='Button',value='Delete', attributes={active=false, id=pre.."cbreDeleteNow",onClick="cbreDeleteNow",alignment='MiddleCenter',colors='#EEEEEE|#F8F8F8|#FFFFFF|rgba(0.78,0.78,0.78,0.5)',fontStyle='Bold',textColor='#000000',tooltip='Click to delete'}}
                  }},
              {tag='Cell'},
              {tag='Cell',attributes={columnSpan='7'}, children = {
                  {tag='Button',value='Save', attributes={interactable=true,id=pre.."cbreSaveNow",onClick="cbreSaveNow",alignment='MiddleCenter',colors='#EEEEEE|#F8F8F8|#FFFFFF|rgba(0.78,0.78,0.78,0.5)',fontStyle='Bold',textColor='#000000',tooltip='Click to save'}}
                  }},
              {tag='Cell',attributes={columnSpan='7'}, children = {
                  {tag='Button',value='Cancel', attributes={id=pre.."cbreCancelNow",onClick="cbreCancelNow",alignment='MiddleCenter',colors='#EEEEEE|#F8F8F8|#FFFFFF|rgba(0.78,0.78,0.78,0.5)',fontStyle='Bold',textColor='#000000',tooltip='Click to cancel'}}
                  }},
          }
      }

  table.insert(miniui.children, createDoing)
  table.insert(miniui.children, typeRow)
  table.insert(miniui.children, typeLineRow)
  table.insert(miniui.children, spaceLineRow)
  table.insert(miniui.children, diceRow)
  table.insert(miniui.children, killingRow)
  table.insert(miniui.children, targetBaseRow)
  table.insert(miniui.children, targetRow)
  table.insert(miniui.children, toHitRow)
  table.insert(miniui.children, toHitTwoRow)
  table.insert(miniui.children, moreRow)
  table.insert(miniui.children, toolRow)
  table.insert(miniui.children, saveNameRow)
  table.insert(miniui.children, saveDeleteRow)

  -- Make spacing for display 10 high with thin gray stripe
  table.insert(miniui.children, cbmakeHeadRow(pre,24,"#999999",{"Combat"},"[Combat]"))
  local changeOptions = {}
  for i,stat in pairs(statList) do
      table.insert(changeOptions,{tag='Option', value=character.stats[stat].name})
  end

  local combatRow1 = {tag='Row', attributes={id=pre.. "combatrow1",preferredHeight=1, active=true},
          children={
              {tag='Cell',attributes={columnSpan=20},children={
                  {tag='VerticalLayout',attributes={id=pre.. "lreflex", active=false, padding="0 0 0 0"},children={
                      {tag='Text', attributes={fontSize=16,resizeTextMaxSize=16,resizeTextMinSize=10,resizeTextForBestFit=true,active=false,text=" <b>Lightning Reflexes</b>", color="#CCCCCC", alignment="MiddleLeft", id=pre..'titleReflex', tooltip="Lightning Reflexes", tooltipPosition='Above'}},
                      {tag='VerticalLayout',attributes={padding="29 0 0 5"},children={
                          {tag='Toggle', attributes={fontSize=14,resizeTextMaxSize=14,resizeTextMinSize=10,resizeTextForBestFit=true,active=false,text="+0 No Lightning Reflex", textColor="#CCCCCC", textAlignment="MiddleLeft", id=pre..'reflexMod1', tooltip="No lightning Reflex", isOn=false, onValueChanged="cbupdateReflexMod",tooltipPosition='Above'}},
                          {tag='Toggle', attributes={fontSize=14,resizeTextMaxSize=14,resizeTextMinSize=10,resizeTextForBestFit=true,active=false,text="+0 No Lightning Reflex", textColor="#CCCCCC", textAlignment="MiddleLeft", id=pre..'reflexMod2', tooltip="No lightning Reflex", isOn=false, onValueChanged="cbupdateReflexMod",tooltipPosition='Above'}},
                          {tag='Toggle', attributes={fontSize=14,resizeTextMaxSize=14,resizeTextMinSize=10,resizeTextForBestFit=true,active=false,text="+0 No Lightning Reflex", textColor="#CCCCCC", textAlignment="MiddleLeft", id=pre..'reflexMod3', tooltip="No lightning Reflex", isOn=false, onValueChanged="cbupdateReflexMod",tooltipPosition='Above'}},
                      }},
                  }},
              }},
          }}
  table.insert(miniui.children, combatRow1)

  local combatRow2 = {tag='Row', attributes={id=pre.. "combatrow2", active=false},
          children={
              {tag='Cell', attributes={columnSpan=20},children={
                  {tag='Text', attributes={fontSize=16,resizeTextMaxSize=16,resizeTextMinSize=10,resizeTextForBestFit=true,active=true,text=" <b>Statuses</b>", color="#CCCCCC", alignment="MiddleLeft", id=pre..'titleStatus', tooltip="Status Configuration", tooltipPosition='Above'}},
              }},
          }}
  table.insert(miniui.children, combatRow2)

  local combatRow3 = {tag='Row', attributes={id=pre.. "combatrow3", active=false},
          children={
              {tag='Cell', attributes={columnSpan=2}},
              {tag='Cell', attributes={columnSpan=8},children={
                  {tag='Toggle', attributes={fontSize=14,resizeTextMaxSize=14,resizeTextMinSize=10,resizeTextForBestFit=true,active=true,text="Stunned", textColor="#CCCCCC", textAlignment="MiddleLeft", id=pre..'statusMod1', tooltip="Stunned: ½ DCV/DMCV", isOn=false, onValueChanged="cbupdateStatusMod",tooltipPosition='Above'}},
              }},
              {tag='Cell', attributes={columnSpan=8},children={
                {tag='Toggle', attributes={fontSize=14,resizeTextMaxSize=14,resizeTextMinSize=10,resizeTextForBestFit=true,active=true,text="Knocked Out", textColor="#CCCCCC", textAlignment="MiddleLeft", id=pre..'statusMod2', tooltip="Knocked Out: 0 OCV, DCV, MCV & x2 Stun", isOn=false, onValueChanged="cbupdateStatusMod",tooltipPosition='Above'}},
              }},
              {tag='Cell', attributes={columnSpan=8},children={
                {tag='Toggle', attributes={fontSize=14,resizeTextMaxSize=14,resizeTextMinSize=10,resizeTextForBestFit=true,active=true,text="Dying", textColor="#CCCCCC", textAlignment="MiddleLeft", id=pre..'statusMod3', tooltip="Dying: Lose one BODY per Turn", isOn=false, onValueChanged="cbupdateStatusMod",tooltipPosition='Above'}},
              }},
          }}
  table.insert(miniui.children, combatRow3)

  local combatRow4 = {tag='Row', attributes={id=pre.. "combatrow4", active=false},
          children={
              {tag='Cell', attributes={columnSpan=2}},
              {tag='Cell', attributes={columnSpan=8},children={
                {tag='Toggle', attributes={fontSize=14,resizeTextMaxSize=14,resizeTextMinSize=10,resizeTextForBestFit=true,active=true,text="Prone", textColor="#CCCCCC", textAlignment="MiddleLeft", id=pre..'statusMod4', tooltip="Prone: ½ DCV, ½ phase to stand", isOn=false, onValueChanged="cbupdateStatusMod",tooltipPosition='Above'}},
              }},
              {tag='Cell', attributes={columnSpan=8},children={
                {tag='Toggle', attributes={fontSize=14,resizeTextMaxSize=14,resizeTextMinSize=10,resizeTextForBestFit=true,active=true,text="Recovery", textColor="#CCCCCC", textAlignment="MiddleLeft", id=pre..'statusMod5', tooltip="Recovery Action: Regain END & STUN equal to REC", isOn=false, onValueChanged="cbupdateStatusMod",tooltipPosition='Above'}},
              }},
              {tag='Cell', attributes={columnSpan=8},children={
                {tag='Toggle', attributes={active=true, fontSize=14,resizeTextMaxSize=14,resizeTextMinSize=10,resizeTextForBestFit=true,text="Custom", textColor="#CCCCCC", textAlignment="MiddleLeft", id=pre..'statusMod6', tooltip="Custom Status, record whatever you want", isOn=false, onValueChanged="cbupdateStatusMod",onClick="cbtestInput",tooltipPosition='Above'}},
                {tag='InputField', attributes={active=false, fontSize=14,resizeTextMaxSize=14,resizeTextMinSize=10,resizeTextForBestFit=true,text="Custom", textColor="#333333", textAlignment="MiddleLeft", id=pre..'statusMod6input', tooltip="Enter your own Custom Status", tooltipPosition='Above',onEndEdit="cbchangeCustomStatus"}},
              }},
              {tag='Cell', attributes={columnSpan=2}},
          }}
  table.insert(miniui.children, combatRow4)

  local combatRow5 = {tag='Row', attributes={id=pre.. "combatrow5", active=false},
          children={
              {tag='Cell', attributes={columnSpan=2}},
              {tag='Cell', attributes={columnSpan=8},children={
                  {tag='Toggle', attributes={fontSize=14,resizeTextMaxSize=14,resizeTextMinSize=10,resizeTextForBestFit=true,active=true,text="Blind", textColor="#CCCCCC", textAlignment="MiddleLeft", id=pre..'statusMod7', tooltip="Blind: Cannot see, lose targeting sense", isOn=false, onValueChanged="cbupdateStatusMod",tooltipPosition='Above'}},
              }},
              {tag='Cell', attributes={columnSpan=8},children={
                  {tag='Toggle', attributes={fontSize=14,resizeTextMaxSize=14,resizeTextMinSize=10,resizeTextForBestFit=true,active=true,text="Deaf", textColor="#CCCCCC", textAlignment="MiddleLeft", id=pre..'statusMod8', tooltip="Deaf: Cannot hear,lose sense", isOn=false, onValueChanged="cbupdateStatusMod",tooltipPosition='Above'}},
              }},
              {tag='Cell', attributes={columnSpan=8},children={
                {tag='Toggle', attributes={active=true, fontSize=14,resizeTextMaxSize=14,resizeTextMinSize=10,resizeTextForBestFit=true,text="Custom", textColor="#CCCCCC", textAlignment="MiddleLeft", id=pre..'statusMod9', tooltip="Custom Status, record whatever you want", isOn=false, onValueChanged="cbupdateStatusMod",onClick="cbtestInput",tooltipPosition='Above'}},
                {tag='InputField', attributes={active=false, fontSize=14,resizeTextMaxSize=14,resizeTextMinSize=10,resizeTextForBestFit=true,text="Custom", textColor="#333333", textAlignment="MiddleLeft", id=pre..'statusMod9input', tooltip="Enter your own Custom Status", tooltipPosition='Above',onEndEdit="cbchangeCustomStatus"}},
              }},
              {tag='Cell', attributes={columnSpan=2}},
          }}
  table.insert(miniui.children, combatRow5)

  table.insert(miniui.children, cbmakeHeadRow(pre,24,"#999999",{"Health"},"[Health]"))

  local healthRow1 = {tag='Row', attributes={id=pre.. "healthrow1", active=false},
    children={
      {tag='Cell', attributes={columnSpan=5},children={
          {tag='Text', attributes={id=pre..'textBody', onClick = "cboriginStat", fontSize=15,resizeTextMaxSize=15,resizeTextMinSize=10,resizeTextForBestFit=true,active=true,text=" Body", color=bodyColor, alignment="MiddleLeft", tooltip="Body Damage", tooltipPosition='Above'}},
      }},
      {tag='Cell',attributes={columnSpan=2},children={
        {tag='Button', attributes={id=pre.. "cblowerBody",text="-", fontSize = 18, textColor="#CCCCCC", onClick="cbChangeNum", colors='#222222|#444444|#222222|#222222',tooltip="Remove one from Body",tooltipPosition="Above"}}
      }},
      {tag='Cell', attributes={columnSpan=3},children={
        {tag='InputField', attributes={ id=pre..'inputBody',textOffset="2 2 2 2", color=bodyColor, textAlignment="MiddleCenter", characterLimit=3, text="999", characterValidation='Integer', fontSize=18,fontStyle="Bold",resizeTextMaxSize=20,resizeTextMinSize=10,resizeTextForBestFit=true, tooltip='Body Number', onEndEdit="cbeditCounter", overrideGlobalCellPadding=true, padding="0 0 0 0", tooltipPosition="Above"}}
      }},
      {tag='Cell',attributes={columnSpan=2},children={
        {tag='Button', attributes={id=pre.. "cbraiseBody",text="+", fontSize = 18, textColor="#CCCCCC", onClick="cbChangeNum", colors='#222222|#444444|#222222|#222222', tooltip="Add one to Body",tooltipPosition="Above"}}
      }},
      {tag='Cell', attributes={columnSpan=1}},
      {tag='Cell', attributes={columnSpan=5},children={
          {tag='Text', attributes={id=pre..'textCustom1',fontSize=16,resizeTextMaxSize=16,resizeTextMinSize=10,resizeTextForBestFit=true,active=true,text=" Custom1", color="#CCCCCC", alignment="MiddleLeft",  tooltip="Custom1 counter", tooltipPosition='Above'}},
      }},
      {tag='Cell',attributes={columnSpan=2},children={
        {tag='Button', attributes={id=pre.. "cblowerCustom1",text="-", fontSize = 18, textColor="#CCCCCC", onClick="cbChangeNum", colors='#222222|#444444|#222222|#222222',tooltip="Remove one from the number",tooltipPosition="Above"}}
      }},
      {tag='Cell', attributes={columnSpan=3},children={
        {tag='InputField', attributes={id=pre..'inputCustom1',textOffset="2 2 2 2", color="#CCCCCC", textAlignment="MiddleCenter", characterLimit=3, text="0", characterValidation='Integer', fontSize=18,fontStyle="Bold",resizeTextMaxSize=20,resizeTextMinSize=10,resizeTextForBestFit=true, tooltip='Custom1 Number', onEndEdit="cbeditCounter", overrideGlobalCellPadding=true, padding="0 0 0 0", tooltipPosition="Above"}}
      }},
      {tag='Cell',attributes={columnSpan=2},children={
        {tag='Button', attributes={id=pre.. "cbraiseCustom1",text="+", fontSize = 18, textColor="#CCCCCC", onClick="cbChangeNum", colors='#222222|#444444|#222222|#222222', tooltip="Add one to the number",tooltipPosition="Above"}}
      }},
    }}
  table.insert(miniui.children, healthRow1)

  local healthRow2 = {tag='Row', attributes={id=pre.. "healthrow2", active=false},
  children={
      {tag='Cell', attributes={columnSpan=5},children={
          {tag='Text', attributes={id=pre..'textStun', onClick = "cboriginStat", fontSize=15,resizeTextMaxSize=15,resizeTextMinSize=10,resizeTextForBestFit=true,active=true,text=" Stun", color=stunColor, alignment="MiddleLeft", tooltip="Stun Damage", tooltipPosition='Above'}},
      }},
      {tag='Cell',attributes={columnSpan=2},children={
        {tag='Button', attributes={id=pre.. "cblowerStun",text="-", fontSize = 18, textColor="#CCCCCC", onClick="cbChangeNum", color='#222222|#444444|#222222|#222222',tooltip="Remove one from Stun",tooltipPosition="Above"}}
      }},
      {tag='Cell', attributes={columnSpan=3},children={
        {tag='InputField', attributes={ id=pre..'inputStun',textOffset="2 2 2 2", color=stunColor, textAlignment="MiddleCenter", characterLimit=3, text="999", characterValidation='Integer', fontSize=18,fontStyle="Bold",resizeTextMaxSize=20,resizeTextMinSize=10,resizeTextForBestFit=true, tooltip='Stun Number', onEndEdit="cbeditCounter", overrideGlobalCellPadding=true, padding="0 0 0 0", tooltipPosition="Above"}}
      }},
      {tag='Cell',attributes={columnSpan=2},children={
        {tag='Button', attributes={id=pre.. "cbraiseStun",text="+", fontSize = 18, textColor="#CCCCCC", onClick="cbChangeNum", colors='#222222|#444444|#222222|#222222', tooltip="Add one to Stun",tooltipPosition="Above"}}
      }},
      {tag='Cell', attributes={columnSpan=1}},
      {tag='Cell', attributes={columnSpan=5},children={
          {tag='Text', attributes={id=pre..'textCustom2',fontSize=16,resizeTextMaxSize=16,resizeTextMinSize=10,resizeTextForBestFit=true,active=true,text=" Custom2", color="#CCCCCC", alignment="MiddleLeft",  tooltip="Custom2 counter", tooltipPosition='Above'}},
      }},
      {tag='Cell',attributes={columnSpan=2},children={
        {tag='Button', attributes={id=pre.. "cblowerCustom2",text="-", fontSize = 18, textColor="#CCCCCC", onClick="cbChangeNum", colors='#222222|#444444|#222222|#222222',tooltip="Remove one from the number",tooltipPosition="Above"}}
      }},
      {tag='Cell', attributes={columnSpan=3},children={
        {tag='InputField', attributes={id=pre..'inputCustom2',textOffset="2 2 2 2", color="#CCCCCC", textAlignment="MiddleCenter", characterLimit=3, text="0", characterValidation='Integer', fontSize=18,fontStyle="Bold",resizeTextMaxSize=20,resizeTextMinSize=10,resizeTextForBestFit=true, tooltip='Custom2 Number', onEndEdit="cbeditCounter", overrideGlobalCellPadding=true, padding="0 0 0 0", tooltipPosition="Above"}}
      }},
      {tag='Cell',attributes={columnSpan=2},children={
        {tag='Button', attributes={id=pre.. "cbraiseCustom2",text="+", fontSize = 18, textColor="#CCCCCC", onClick="cbChangeNum", colors='#222222|#444444|#222222|#222222', tooltip="Add one to the number",tooltipPosition="Above"}}
      }},
  }}
  table.insert(miniui.children, healthRow2)

  local healthRow3 = {tag='Row', attributes={id=pre.. "healthrow3", active=false},
  children={
      {tag='Cell', attributes={columnSpan=5},children={
        {tag='Text', attributes={id=pre..'textEnd', onClick = "cboriginStat",  fontSize=15,resizeTextMaxSize=15,resizeTextMinSize=10,resizeTextForBestFit=true,active=true,text=" End", color=endColor, alignment="MiddleLeft", tooltip="End Counter", tooltipPosition='Above'}},
      }},
      {tag='Cell',attributes={columnSpan=2},children={
        {tag='Button', attributes={id=pre.. "cblowerEnd",text="-", fontSize = 18, textColor="#CCCCCC", onClick="cbChangeNum", color='#222222|#444444|#222222|#222222',tooltip="Remove one from End",tooltipPosition="Above"}}
      }},
      {tag='Cell', attributes={columnSpan=3},children={
        {tag='InputField', attributes={ id=pre..'inputEnd',textOffset="2 2 2 2", color=endColor, textAlignment="MiddleCenter", characterLimit=3, text="999", characterValidation='Integer', fontSize=18,fontStyle="Bold",resizeTextMaxSize=20,resizeTextMinSize=10,resizeTextForBestFit=true, tooltip='End Number', onEndEdit="cbeditCounter", overrideGlobalCellPadding=true, padding="0 0 0 0", tooltipPosition="Above"}}
      }},
      {tag='Cell',attributes={columnSpan=2},children={
        {tag='Button', attributes={id=pre.. "cbraiseEnd",text="+", fontSize = 18, textColor="#CCCCCC", onClick="cbChangeNum", colors='#222222|#444444|#222222|#222222', tooltip="Add one to End",tooltipPosition="Above"}}
      }},
      {tag='Cell', attributes={columnSpan=1}},
      {tag='Cell', attributes={columnSpan=5},children={
          {tag='Text', attributes={id=pre..'textCustom3',fontSize=16,resizeTextMaxSize=16,resizeTextMinSize=10,resizeTextForBestFit=true,active=true,text=" Custom3", color="#CCCCCC", alignment="MiddleLeft",  tooltip="Custom3 counter", tooltipPosition='Above'}},
      }},
      {tag='Cell',attributes={columnSpan=2},children={
        {tag='Button', attributes={id=pre.. "cblowerCustom3",text="-", fontSize = 18, textColor="#CCCCCC", onClick="cbChangeNum", colors='#222222|#444444|#222222|#222222',tooltip="Remove one from the number",tooltipPosition="Above"}}
      }},
      {tag='Cell', attributes={columnSpan=3},children={
        {tag='InputField', attributes={id=pre..'inputCustom3',textOffset="2 2 2 2", color="#CCCCCC", textAlignment="MiddleCenter", characterLimit=3, text="0", characterValidation='Integer', fontSize=18,fontStyle="Bold",resizeTextMaxSize=20,resizeTextMinSize=10,resizeTextForBestFit=true, tooltip='Custom3 Number', onEndEdit="cbeditCounter", overrideGlobalCellPadding=true, padding="0 0 0 0", tooltipPosition="Above"}}
      }},
      {tag='Cell',attributes={columnSpan=2},children={
        {tag='Button', attributes={id=pre.. "cbraiseCustom3",text="+", fontSize = 18, textColor="#CCCCCC", onClick="cbChangeNum", colors='#222222|#444444|#222222|#222222', tooltip="Add one to the number",tooltipPosition="Above"}}
      }},
  }}
  table.insert(miniui.children, healthRow3)

  table.insert(miniui.children, cbmakeHeadRow(pre,24,"#999999",{"Link"},"[Link]"))

  local linkRow1 = {tag='Row', attributes={id=pre.. "linkrow1", active=false},
    children={
      {tag='Cell', attributes={columnSpan=2},children={
        {tag='Image', attributes={ id=pre..'linkImage',image="ui_player", onClick="cblinkToFigure", tooltip="Link to a figure"}},
      }},
      {tag='Cell', attributes={columnSpan=6},children={
        {tag='Text', attributes={id=pre..'linkText', onClick="cblinkToFigure", fontSize=15,resizeTextMaxSize=15,resizeTextMinSize=10,resizeTextForBestFit=true,active=true,text=" Link to figure", color="#CCCCCC", alignment="MiddleLeft", tooltip="Link to a figure", tooltipPosition='Above'}},
      }},
      {tag='Cell', attributes={columnSpan=2},children={
        {tag='Text', attributes={id=pre..'linkCancel', onClick = "linkKill", fontSize=15,resizeTextMaxSize=15,resizeTextMinSize=10,resizeTextForBestFit=true,active=true,text=crossMark, color="#CC0000", alignment="MiddleLeft", tooltip="Delete link to figure", tooltipPosition='Above'}},
      }},
      {tag='Cell', attributes={columnSpan=8},children={
        {tag='Text', attributes={id=pre..'linkName', onClick = "cbcenterOnFigure", fontSize=15,resizeTextMaxSize=15,resizeTextMinSize=10,resizeTextForBestFit=true,active=true,text="", color="#00CC00", alignment="MiddleLeft", tooltip="Figure linked to", tooltipPosition='Above'}},
      }},
    }}

  table.insert(miniui.children, linkRow1)
  table.insert(minipanel.children, miniui)
  return minipanel
end

function buildCombatUI()
  local combatMini = {}
  for i=1,maxLibSize do
    table.insert(combatMini, {tag='Row', attributes={active=false,id="nextRowPlayer"..i},
      children={
        {tag='Cell', attributes={columnSpan=1}, children={
          {tag='Text',attributes={id="nextRowPhase"..i, text="",fontSize="26",alignment="MiddleCenter", color="#999999"}},
        }},
        {tag='Cell', attributes={columnSpan=1}, children={
            {tag="ProgressBar", attributes={id="bodyBar"..i,ignoreLayout="true",scale="4 .19 1",rotation="0 0 90",showPercentageText="false",color="#440000",fillImageColor=bodyColor,percentage=tostring(math.random (100)),tooltip="Body 13/15"}},
            {tag="ProgressBar", attributes={id="stunBar"..i,ignoreLayout="true",scale="4 .19 1",rotation="0 0 90",showPercentageText="false",color="#444400",fillImageColor=stunColor,percentage=tostring(math.random (100)),tooltip="Stun 13/15"}},
            {tag="ProgressBar", attributes={id="endBar"..i,ignoreLayout="true",scale="4 .19 1",rotation="0 0 90",showPercentageText="false",color="#004400",fillImageColor=endColor,percentage=tostring(math.random (100)),tooltip="End 13/15"}},
        }},
        {tag='Cell', attributes={columnSpan=11}, children={
            {tag='Text',attributes={id="nextRowName"..i,class="name next"}},
        }},
        {tag='Cell', attributes={columnSpan=2}, children={
          {tag='Text',attributes={id="nextRowAbort"..i,text="", fontSize=26,resizeTextForBestFit="true",resizeTextMinSize="14",resizeTextMaxSize="28",alignment="UpperCenter", color="#999999"}},
        }},
        {tag='Cell', attributes={columnSpan=2}, children={
          {tag='Text',attributes={id="nextRowClock"..i, text="", fontSize=27,resizeTextForBestFit="true",resizeTextMinSize="14",resizeTextMaxSize="28",alignment="UpperLeft", color="#CCCCCC"}},
        }},
      }}
    )
  end

  for i=1,maxLibSize do
    table.insert(combatMini, {tag='Row', attributes={active=false,id="combatRowPlayer"..i},
      children={
        {tag='Cell'},
        {tag='Cell'},
        {tag='Cell', attributes={columnSpan=11}, children={
          {tag='Text',attributes={id="combatRowName"..i,class="name"}},
        }},
        {tag='Cell', attributes={columnSpan=2}, children={
          {tag='Text',attributes={id="combatRowAbort"..i,color="#CCCCCC", fontSize=20, alignment="MiddleCenter", fontStyle="Bold", text=crossMark, tooltip = "Click to remove from Combat",}},
        }},
      }}
    )
  end

  return combatMini
end

function buildTurnViewerUI()

  local miniui = {
      tag='TableLayout', attributes={active=true, id='tvturnUI', outline="#999999", visibility="Black|Diamonds|Spades", autoCalculateHeight=true, ignoreLayout=true, offsetXY='0 0', width=515, rectAlignment='MiddleCenter', columnWidths="30 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20", cellBackgroundColor='clear', cellPadding='2 2 2 2', color='#050505'},
      children={}
  }

  table.insert(miniui.children,
    {tag='Row', attributes={id='tvnameRow'},
      children={
        {tag='Cell', attributes={columnSpan=24}, children={
          {tag='Text',attributes={id="tvtitle", alignment="MiddleLeft", text=" Turn Viewer - Turn 1 - Segment 12 ", tooltip="", color="#CCCCCC", fontSize=20}}
      }},
    }}
  )

  for i=1,#charLib do
    table.insert(miniui.children,
      {tag='Row', attributes={active="false", id="tvnextRowPlayer" .. i},
        children={
          {tag='Cell', attributes={columnSpan=1}, children={
            {tag='Text',attributes={id="tvnextRowPhase"..i, alignment="MiddleCenter", text="", tooltip="", color="#999999", fontSize=26}}
          }},
          {tag='Cell', attributes={columnSpan=12}, children={
            {tag='Text',attributes={id="tvnextRowName"..i, class="name"}}
          }},
          {tag='Cell', attributes={columnSpan=12}, children={
            {tag='Text',attributes={id="tvnextRowPhases"..i, class="name", text="ⓡ――③――⑥――⑨――⑫"}}
          }},
      }}
    )
  end

  local minipanel = {
    tag='Panel', attributes={id="tvpanel", allowDragging=true,returnToOriginalPositionWhenReleased=false,rectAlignment="LowerRight",offsetXY="0 0",padding="0 0 0 0", width=510, height=37},
    children=miniui
  }

  return minipanel
end

function buildUI() -- Rebuild entire UI for deployment
  local ui = buildUIDefaults()

  table.insert(ui,buildHSMUI())

  for key,_ in pairs(players) do
    table.insert(ui,buildBrowserUI(string.upper(string.sub(key,1,3)),bCharacter))
  end

  --table.insert(ui,buildBrowserUI("BLA"),bCharacter)
  --table.insert(ui,buildBrowserUI("BLU"),bCharacter)
  --table.insert(ui,buildBrowserUI("RED"),bCharacter)
  --table.insert(ui,buildBrowserUI("GRE"),bCharacter)
  --table.insert(ui,buildBrowserUI("YEL"),bCharacter)
  --table.insert(ui,buildBrowserUI("ORA"),bCharacter)
  --table.insert(ui,buildBrowserUI("TEA"),bCharacter)
  --table.insert(ui,buildBrowserUI("PUR"),bCharacter)

  table.insert(ui,buildTurnViewerUI())

  UI.setXmlTable(ui)

  for key,_ in pairs(players) do
    Wait.frames(function() cbhideAtBuild(key)  end, 6)
  end

  --Wait.frames(function() cbhideAtBuild("black")  end, 6)
  --Wait.frames(function() cbhideAtBuild("blue")  end, 6)
  --Wait.frames(function() cbhideAtBuild("red")  end, 6)
  --Wait.frames(function() cbhideAtBuild("green")  end, 6)
  --Wait.frames(function() cbhideAtBuild("yellow")  end, 6)
  --Wait.frames(function() cbhideAtBuild("orange")  end, 6)
  --Wait.frames(function() cbhideAtBuild("teal")  end, 6)
  --Wait.frames(function() cbhideAtBuild("purple")  end, 6)
  --Wait.frames(function() cbhideAtBuild("pink")  end, 6)
  --Wait.frames(function() cbhideAtBuild("brown")  end, 6)

  Wait.frames(function() reDrawPreCombatUI(true) end, 7)
end

-- [[

-- Global Event Handler Functions

-- ]]

function onObjectDestroy(obj)
  -- use this section to clean up that object GUID if it is associated with a character
  local g = obj.guid
  for i=1,maxLibSize do
      if ((g == charLibGUID[i]) or (g == charLib[i].link)) then
        charLibGUID[i] = nil
        if charLib[i].link then
          charLib[i].link = nil
          -- right here would be code to update the UI for that player to remove the name
        end
        --log("Object '"..(obj.getName() or "(no name)").."' ("..g..") was destroyed, removing note")
      end
  end
end

function onPlayerChangeColor(color)
  -- doesn't handle player changing from color to black
  -- need to think of solution
  if (color != "Grey") then
      for personcolour, person in pairs(players) do
        if Player[color].steam_name == person.steam then
          person.active = false
          person.steam = ""
          updatesUI("player"..personcolour, {
            image = "ui_noplayer",
            color = person.color.."33",
            tooltip = "Player " .. personcolour .. " inactive",
          })
          break
        end
      end
      if (color != "Black") then
        players[string.lower(color)].steam = Player[color].steam_name
        players[string.lower(color)].active = true
        updatesUI("player"..string.lower(color), {
          image = "ui_player",
          color = color,
          tooltip = Player[color].steam_name,
        })
      end
    end
end

function onPlayerDisconnect(person)
    --pl (person)
    local color = string.lower(person.color)
    --pl (color)
    players[color].steam = ""
    players[color].active = false
    updatesUI("player"..color, {
      image = "ui_noplayer",
      color = players[color].color.."33",
      tooltip = "Player " .. color .. " inactive",
    })
end

function onLoad() -- prepare all activities upon load
  colorSet =  Set(colorDesc)
  buildAssets()
  sccreateLibrary(maxLibSize)
  scloadBaseCharacter(baseCharacter)
  buildUI()
  printToAll ("Hero System loading",{r=0,g=0.2,b=0})
  printToAll ("please wait ≈30 seconds",{r=0,g=0.2,b=0})
end
